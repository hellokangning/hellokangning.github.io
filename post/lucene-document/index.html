<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Document in Lucene - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="In Lucene, a Document is the unit of search and index.
 An index consists of a sequence of documents. A document contains of one or more Fields. A field is a named sequence of terms. A term is a string.  In order to index data with Lucene, you must convert it to a stream of plain-text tokens firstly. Based on the stream, the document containning fields will be created." />

  <meta name="keywords" content="elasticsearch, python, hbase" />






<meta name="generator" content="Hugo 0.26" />


<link rel="canonical" href="https://hellokangning.github.io/post/lucene-document/" />

<link rel="apple-touch-icon" sizes="180x180" href="https://hellokangning.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hellokangning.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://hellokangning.github.io/favicon-16x16.png">
<link rel="icon" href="https://hellokangning.github.io/favicon.ico" />
<link rel="manifest" href="https://hellokangning.github.io/manifest.json">
<link rel="mask-icon" href="https://hellokangning.github.io/safari-pinned-tab.svg" color="#5bbad5">




<link href="https://hellokangning.github.io/dist/even.min.css?v=2.6.6" rel="stylesheet">
<link href="https://hellokangning.github.io/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="Document in Lucene" />
<meta property="og:description" content="In Lucene, a Document is the unit of search and index.
 An index consists of a sequence of documents. A document contains of one or more Fields. A field is a named sequence of terms. A term is a string.  In order to index data with Lucene, you must convert it to a stream of plain-text tokens firstly. Based on the stream, the document containning fields will be created." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/post/lucene-document/" />



<meta property="article:published_time" content="2017-08-07T18:52:01&#43;08:00"/>
<meta property="article:modified_time" content="2017-08-07T18:52:01&#43;08:00"/>











<meta itemprop="name" content="Document in Lucene">
<meta itemprop="description" content="In Lucene, a Document is the unit of search and index.
 An index consists of a sequence of documents. A document contains of one or more Fields. A field is a named sequence of terms. A term is a string.  In order to index data with Lucene, you must convert it to a stream of plain-text tokens firstly. Based on the stream, the document containning fields will be created.">


<meta itemprop="dateModified" content="2017-08-07T18:52:01&#43;08:00" />
<meta itemprop="wordCount" content="885">



<meta itemprop="keywords" content="Lucene," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Document in Lucene"/>
<meta name="twitter:description" content="In Lucene, a Document is the unit of search and index.
 An index consists of a sequence of documents. A document contains of one or more Fields. A field is a named sequence of terms. A term is a string.  In order to index data with Lucene, you must convert it to a stream of plain-text tokens firstly. Based on the stream, the document containning fields will be created."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="https://hellokangning.github.io/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="https://hellokangning.github.io/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="https://hellokangning.github.io/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="https://hellokangning.github.io/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="https://hellokangning.github.io/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="https://hellokangning.github.io/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="https://hellokangning.github.io/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Document in Lucene</h1>

      <div class="post-meta">
        <span class="post-time"> Aug 07, 2017 </span>
        <div class="post-category">
            
              <a href="https://hellokangning.github.io/categories/elasticsearch/"> Elasticsearch </a>
            
          </div>
        <span class="more-meta"> 885 word </span>
        <span class="more-meta"> 5 min read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
      <nav id="TableOfContents">
<ul>
<li><a href="#field">Field</a></li>
<li><a href="#document">Document</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<p>In Lucene, a <strong>Document</strong> is the unit of search and index.</p>

<ul>
<li>An index consists of a sequence of documents.</li>
<li>A document contains of one or more <strong>Fields</strong>.</li>
<li>A field is a named sequence of <strong>terms</strong>.</li>
<li>A term is a string.</li>
</ul>

<p><img src="https://hellokangning.github.io/images/indexing-process.jpg" alt="" /></p>

<p>In order to index data with Lucene, you must convert it to a stream of plain-text tokens firstly. Based on the stream, the document containning fields will be created. After that, you can call <code>addDocument</code> method in <code>IndexWriter</code> class to transmit it to index. During this procedure, analyzer may be used to make the data more suitable for indexing.</p>

<p><img src="https://hellokangning.github.io/images/lucene-document.png" alt="Class Diagram" /></p>

<h1 id="field">Field</h1>

<p>In Lucene, fields may be stored, in which case their text is stored in the index literally, in a non-inverted manner. Fields that are inverted are called indexed. <strong>A field may be both stored and indexed</strong>.</p>

<p>The text of a field may be tokenized into terms to be indexed, or the text of a field may be used literally as a term to be indexed. Most fields are tokenized, but sometimes it is useful for certain identifier fields to be indexed literally.</p>

<p>Each field has three parts: name, type and value. Values may be text (String, Reader or pre-analyzed TokenStream), binary (byte[]), or numeric (a Number). Fields are optionally stored in the index, so that they may be returned with hits on the document.</p>

<p>Then, Let&rsquo;s deep into source code,</p>

<pre><code class="language-java">public class Field implements IndexableField {

  protected final FieldType type;
  protected final String name;
  protected float boost = 1.0f;
  
  /**
   * data can be converted to 
   * 1. Numberic Value
   * 2. Binary Value
   * 3. String Value
   * 4. Reader Value
   */
  protected Object fieldsData;

  /** Pre-analyzed tokenStream for indexed fields; this is
   * separate from fieldsData because you are allowed to
   * have both; eg maybe field has a String value but you
   * customize how it's tokenized */
  protected TokenStream tokenStream;

  /**
   *...
   * getters and settins for above attributes.
   */


  /**
   * Creates the TokenStream used for indexing this field.  If appropriate,
   * @param analyzer Analyzer that should be used to create the TokenStreams from
   * @param reuse TokenStream for a previous instance of this field name. This allows
   * custom field types (like StringField and NumericField) that do not use
   *              the analyzer to still have good performance. Note: the passed-in type
   *              may be inappropriate, for example if you mix up different types of Fields
   *              for the same field name. So it's the responsibility of the implementation to
   *              check.
   * @return TokenStream value for indexing the document.  Should always return
  */
  @Override
  public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
    if (fieldType().indexOptions() == IndexOptions.NONE) {
      // Not indexed
      return null;
    }

    final FieldType.LegacyNumericType numericType = fieldType().numericType();
    if (numericType != null) {
      if (!(reuse instanceof LegacyNumericTokenStream &amp;&amp; ((LegacyNumericTokenStream)reuse).getPrecisionStep() == type.numericPrecisionStep())) {
        // lazy init the TokenStream as it is heavy to instantiate
        // (attributes,...) if not needed (stored field loading)
        reuse = new LegacyNumericTokenStream(type.numericPrecisionStep());
      }
      final LegacyNumericTokenStream nts = (LegacyNumericTokenStream) reuse;
      // initialize value in TokenStream
      final Number val = (Number) fieldsData;
      switch (numericType) {
      case INT:
        nts.setIntValue(val.intValue());
        break;
      case LONG:
        nts.setLongValue(val.longValue());
        break;
      case FLOAT:
        nts.setFloatValue(val.floatValue());
        break;
      case DOUBLE:
        nts.setDoubleValue(val.doubleValue());
        break;
      default:
        throw new AssertionError(&quot;Should never get here&quot;);
      }
      return reuse;
    }

    if (!fieldType().tokenized()) {
      if (stringValue() != null) {
        if (!(reuse instanceof StringTokenStream)) {
          // lazy init the TokenStream as it is heavy to instantiate
          // (attributes,...) if not needed
          reuse = new StringTokenStream();
        }
        ((StringTokenStream) reuse).setValue(stringValue());
        return reuse;
      } else if (binaryValue() != null) {
        if (!(reuse instanceof BinaryTokenStream)) {
          // lazy init the TokenStream as it is heavy to instantiate
          // (attributes,...) if not needed
          reuse = new BinaryTokenStream();
        }
        ((BinaryTokenStream) reuse).setValue(binaryValue());
        return reuse;
      } else {
        throw new IllegalArgumentException(&quot;Non-Tokenized Fields must have a String value&quot;);
      }
    }

    if (tokenStream != null) {
      return tokenStream;
    } else if (readerValue() != null) {
      return analyzer.tokenStream(name(), readerValue());
    } else if (stringValue() != null) {
      return analyzer.tokenStream(name(), stringValue());
    }  

    throw new IllegalArgumentException(&quot;Field must have either TokenStream, String, Reader or Number value; got &quot; + this);
  }
}
</code></pre>

<h1 id="document">Document</h1>

<p>Documents are the unit of indexing and search. A Document is a set of fields. Each field has a name and a textual value. A field may be stored with the document, in which case it is returned with search hits on the document. Thus each document should typically contain one or more stored fields which uniquely identify it.</p>

<pre><code class="language-java">public final class Document implements Iterable&lt;IndexableField&gt; {

  private final List&lt;IndexableField&gt; fields = new ArrayList&lt;&gt;();

  @Override
  public Iterator&lt;IndexableField&gt; iterator() {
    return fields.iterator();
  }

  /**
  Adds a field to a document.
  Several fields may be added with the same name. 
  */
  public final void add(IndexableField field) {
    fields.add(field);
  }

  public final void removeField(String name) {
    Iterator&lt;IndexableField&gt; it = fields.iterator();
    while (it.hasNext()) {
      IndexableField field = it.next();
      if (field.name().equals(name)) {
        it.remove();
        return;
      }
    }
  }

  /**
  * Returns an array of bytes for the first (or only) field that has the name
  * specified as the method parameter. 
  */
  public final BytesRef getBinaryValue(String name) {
    for (IndexableField field : fields) {
      if (field.name().equals(name)) {
        final BytesRef bytes = field.binaryValue();
        if (bytes != null) {
          return bytes;
        }
      }
    }
    return null;
  }

  public final IndexableField getField(String name) {
    for (IndexableField field : fields) {
      if (field.name().equals(name)) {
        return field;
      }
    }
    return null;
  }
}
</code></pre>

    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="https://hellokangning.github.io/tags/lucene/">Lucene</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://hellokangning.github.io/post/how-to-read-english-books/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to Read English Books</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://hellokangning.github.io/post/guice-usage-in-es/">
            <span class="next-text nav-default">Guice Usage in Elasticsearch</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'guoqing';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com/" class="dsq-brlink" target="_blank">comments powered by <span class="logo-disqus">Disqus</span></a>

  
      </div>  
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
  <a href="https://hellokangning.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="https://hellokangning.github.io/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="https://hellokangning.github.io/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="https://hellokangning.github.io/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="https://hellokangning.github.io/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="https://hellokangning.github.io/dist/even.min.js?v=2.6.6"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-105833321-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



</body>
</html>
