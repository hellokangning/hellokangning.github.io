<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Directory in Lucene - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="Directory represents the storage location of the indexes and generally it is a list of files. These files are called index files. Index files are normally created once and then used for read operation or can be deleted.

" />
<meta name="keywords" content="Lucene, Directory" />







<meta name="generator" content="Hugo 0.44" />


<link rel="canonical" href="https://hellokangning.github.io/post/lucene-directory/" />

<link rel="apple-touch-icon" sizes="180x180" href="https://hellokangning.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hellokangning.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://hellokangning.github.io/favicon-16x16.png">
<link rel="manifest" href="https://hellokangning.github.io/manifest.json">
<link rel="mask-icon" href="https://hellokangning.github.io/safari-pinned-tab.svg" color="#5bbad5">







<link href="https://hellokangning.github.io/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="https://hellokangning.github.io/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Directory in Lucene" />
<meta property="og:description" content="Directory represents the storage location of the indexes and generally it is a list of files. These files are called index files. Index files are normally created once and then used for read operation or can be deleted.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/post/lucene-directory/" />



<meta property="article:published_time" content="2017-09-05T16:26:31&#43;08:00"/>

<meta property="article:modified_time" content="2017-09-05T16:26:31&#43;08:00"/>











<meta itemprop="name" content="Directory in Lucene">
<meta itemprop="description" content="Directory represents the storage location of the indexes and generally it is a list of files. These files are called index files. Index files are normally created once and then used for read operation or can be deleted.

">


<meta itemprop="datePublished" content="2017-09-05T16:26:31&#43;08:00" />
<meta itemprop="dateModified" content="2017-09-05T16:26:31&#43;08:00" />
<meta itemprop="wordCount" content="2733">



<meta itemprop="keywords" content="Lucene," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Directory in Lucene"/>
<meta name="twitter:description" content="Directory represents the storage location of the indexes and generally it is a list of files. These files are called index files. Index files are normally created once and then used for read operation or can be deleted.

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="https://hellokangning.github.io/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="https://hellokangning.github.io/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="https://hellokangning.github.io/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="https://hellokangning.github.io/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="https://hellokangning.github.io/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="https://hellokangning.github.io/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="https://hellokangning.github.io/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://hellokangning.github.io/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Directory in Lucene</h1>

      <div class="post-meta">
        <span class="post-time"> Sep 05, 2017 </span>
        <div class="post-category">
            
              <a href="https://hellokangning.github.io/categories/elasticsearch/"> Elasticsearch </a>
            
          </div>
        <span class="more-meta"> 2733 words </span>
        <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#directory">Directory</a>
<ul>
<li><a href="#basedirectory">BaseDirectory</a></li>
<li><a href="#ramdirectory">RAMDirectory</a></li>
<li><a href="#fsdirectory">FSDirectory</a></li>
</ul></li>
<li><a href="#indexinput">IndexInput</a>
<ul>
<li><a href="#bufferedindexinput">BufferedIndexInput</a></li>
</ul></li>
<li><a href="#indexoutput">IndexOutput</a>
<ul>
<li><a href="#ramoutputstream">RAMOutputStream</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p><code>Directory</code> represents the storage location of the indexes and generally it is a list of files. These files are called index files. Index files are normally created once and then used for read operation or can be deleted.</p>

<p></p>

<p><img src="https://hellokangning.github.io/images/lucene-directory.png" alt="Class Diagram" /></p>

<h1 id="directory">Directory</h1>

<p><code>Directory</code> class is abstract with many to-be-implemented methods related to file, input and output.</p>

<ul>
<li><code>IndexInput</code> is returned from reading an existing file.</li>
<li><code>IndexOutput</code> is created for writing a new, empty file in the directory.</li>
<li>Directory locking is implemented by an instance of <code>LockFactory</code> (abstract class).</li>
</ul>

<pre><code class="language-java">public abstract class Directory implements Closeable {

  
  // Returns an array of strings, one for each entry in the directory, in sorted (UTF16, java's String.compare) order.
  public abstract String[] listAll() throws IOException;

  // Removes an existing file in the directory. 
  public abstract void deleteFile(String name) throws IOException;

  // Returns the length of a file in the directory.
  public abstract long fileLength(String name) throws IOException;

  /** Creates a new, empty file in the directory with the given name.
      Returns a stream writing this file. */
  public abstract IndexOutput createOutput(String name, IOContext context) throws IOException;

  /** Creates a new, empty file for writing in the directory, with a
   *  temporary file name including prefix and suffix, ending with the
   *  reserved extension .tmp. */
  public abstract IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException;

  /**
   * Ensure that any writes to these files are moved to
   * stable storage.  Lucene uses this to properly commit
   * changes to the index, to prevent a machine/OS crash
   * from corrupting the index.
   */
  public abstract void sync(Collection&lt;String&gt; names) throws IOException;
  
  /**
   * Renames {@code source} to {@code dest} as an atomic operation,
   * where {@code dest} does not yet exist in the directory.
   * &lt;p&gt;
   * Notes: This method is used by IndexWriter to publish commits.
   * It is ok if this operation is not truly atomic, for example
   * both {@code source} and {@code dest} can be visible temporarily.
   * It is just important that the contents of {@code dest} appear
   * atomically, or an exception is thrown.
   */
  public abstract void rename(String source, String dest) throws IOException;

  /**
   * Ensure that directory metadata, such as recent file renames, are made
   * durable.
   */
  public abstract void syncMetaData() throws IOException;
  
  /** Returns a stream reading an existing file. */
  public abstract IndexInput openInput(String name, IOContext context) throws IOException;
  
  /** Returns a stream reading an existing file, computing checksum as it reads */
  public ChecksumIndexInput openChecksumInput(String name, IOContext context) throws IOException {
    return new BufferedChecksumIndexInput(openInput(name, context));
  }
  
  /** 
   * Returns an obtained {@link Lock}.
   * @param name the name of the lock file
   */
  public abstract Lock obtainLock(String name) throws IOException;

  /** Closes the store. */
  @Override
  public abstract void close() throws IOException;

  @Override
  public String toString() {
    return getClass().getSimpleName() + '@' + Integer.toHexString(hashCode());
  }

  /**
   * Copies the file &lt;i&gt;src&lt;/i&gt; in &lt;i&gt;from&lt;/i&gt; to this directory under the new
   * file name &lt;i&gt;dest&lt;/i&gt;.
   */
  public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {
    boolean success = false;
    try (IndexInput is = from.openInput(src, context);
         IndexOutput os = createOutput(dest, context)) {
      os.copyBytes(is, is.length());
      success = true;
    } finally {
      if (!success) {
        IOUtils.deleteFilesIgnoringExceptions(this, dest);
      }
    }
  }

  protected void ensureOpen() throws AlreadyClosedException {}
}
</code></pre>

<h2 id="basedirectory">BaseDirectory</h2>

<p><code>BaseDirectory</code> is a base implementation for a concrete <code>Directory</code> that uses a <code>LockFactory</code> for locking, still abstract.</p>

<pre><code class="language-java">public abstract class BaseDirectory extends Directory {

  volatile protected boolean isOpen = true;

  /** Holds the LockFactory instance (implements locking for
   * this Directory instance). */
  protected final LockFactory lockFactory;

  /** Sole constructor. */
  protected BaseDirectory(LockFactory lockFactory) {
    super();
    if (lockFactory == null) {
      throw new NullPointerException(&quot;LockFactory must not be null, use an explicit instance!&quot;);
    }
    this.lockFactory = lockFactory;
  }

  @Override
  public final Lock obtainLock(String name) throws IOException {
    return lockFactory.obtainLock(this, name);
  }

  @Override
  protected final void ensureOpen() throws AlreadyClosedException {
    if (!isOpen) {
      throw new AlreadyClosedException(&quot;this Directory is closed&quot;);
    }
  }
}
</code></pre>

<h2 id="ramdirectory">RAMDirectory</h2>

<p><code>RAMDirectory</code> extends <code>BaseDirectory</code> and provides A memory-resident <code>Directory</code> implementation. Its locking implementation is by default the <code>SingleInstanceLockFactory</code>.</p>

<pre><code class="language-java">public class RAMDirectory extends BaseDirectory implements Accountable {
  // fileName -&gt; RAMFile
  protected final Map&lt;String,RAMFile&gt; fileMap = new ConcurrentHashMap&lt;&gt;();
  protected final AtomicLong sizeInBytes = new AtomicLong();
  
  /** Used to generate temp file names in {@link #createTempOutput}. */
  private final AtomicLong nextTempFileCounter = new AtomicLong();

  /** Constructs an empty {@link Directory}. */
  public RAMDirectory() {
    this(new SingleInstanceLockFactory());
  }

  /** Constructs an empty {@link Directory} with the given {@link LockFactory}. */
  public RAMDirectory(LockFactory lockFactory) {
    super(lockFactory);
  }

  /**
   * Creates a new RAMDirectory instance from a different
   * Directory implementation. This can be used to load
   * a disk-based index into memory.
   */
  public RAMDirectory(FSDirectory dir, IOContext context) throws IOException {
    this(dir, false, context);
  }
  
  private RAMDirectory(FSDirectory dir, boolean closeDir, IOContext context) throws IOException {
    this();
    for (String file : dir.listAll()) {
      if (!Files.isDirectory(dir.getDirectory().resolve(file))) {
        copyFrom(dir, file, file, context);
      }
    }
    if (closeDir) {
      dir.close();
    }
  }

  @Override
  public final String[] listAll() {
    ensureOpen();

    Set&lt;String&gt; fileNames = fileMap.keySet();
    List&lt;String&gt; names = new ArrayList&lt;&gt;(fileNames.size());
    for (String name : fileNames) {
      names.add(name);
    }
    String[] namesArray = names.toArray(new String[names.size()]);
    Arrays.sort(namesArray);
    return namesArray;
  }

  public final boolean fileNameExists(String name) {
    ensureOpen();
    return fileMap.containsKey(name);
  }

  /** Returns the length in bytes of a file in the directory. */
  @Override
  public final long fileLength(String name) throws IOException {
    ensureOpen();
    RAMFile file = fileMap.get(name);
    if (file == null) {
      throw new FileNotFoundException(name);
    }
    return file.getLength();
  }
  
  /**
   * Return total size in bytes of all files in this directory. This is
   * currently quantized to RAMOutputStream.BUFFER_SIZE.
   */
  @Override
  public final long ramBytesUsed() {
    ensureOpen();
    return sizeInBytes.get();
  }
  
  @Override
  public Collection&lt;Accountable&gt; getChildResources() {
    return Accountables.namedAccountables(&quot;file&quot;, fileMap);
  }
  
  @Override
  public void deleteFile(String name) throws IOException {
    ensureOpen();
    RAMFile file = fileMap.remove(name);
    if (file != null) {
      file.directory = null;
      sizeInBytes.addAndGet(-file.sizeInBytes);
    } else {
      throw new FileNotFoundException(name);
    }
  }

  @Override
  public IndexOutput createOutput(String name, IOContext context) throws IOException {
    ensureOpen();
    RAMFile file = newRAMFile();
    if (fileMap.putIfAbsent(name, file) != null) {
      throw new FileAlreadyExistsException(name);
    }
    return new RAMOutputStream(name, file, true);
  }

  @Override
  public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {
    ensureOpen();

    // Make the file first...
    RAMFile file = newRAMFile();

    // ... then try to find a unique name for it:
    while (true) {
      String name = IndexFileNames.segmentFileName(prefix, suffix + &quot;_&quot; + Long.toString(nextTempFileCounter.getAndIncrement(), Character.MAX_RADIX), &quot;tmp&quot;);
      if (fileMap.putIfAbsent(name, file) == null) {
        return new RAMOutputStream(name, file, true);
      }
    }
  }

  /**
   * Returns a new {@link RAMFile} for storing data. This method can be
   * overridden to return different {@link RAMFile} impls, that e.g. override
   * {@link RAMFile#newBuffer(int)}.
   */
  protected RAMFile newRAMFile() {
    return new RAMFile(this);
  }

  @Override
  public void sync(Collection&lt;String&gt; names) throws IOException {
  }

  @Override
  public void rename(String source, String dest) throws IOException {
    ensureOpen();
    RAMFile file = fileMap.get(source);
    if (file == null) {
      throw new FileNotFoundException(source);
    }
    if (fileMap.putIfAbsent(dest, file) != null) {
      throw new FileAlreadyExistsException(dest);
    }
    if (!fileMap.remove(source, file)) {
      throw new IllegalStateException(&quot;file was unexpectedly replaced: &quot; + source);
    }
    fileMap.remove(source);
  }

  @Override
  public void syncMetaData() throws IOException {
    // we are by definition not durable!
  }
  
  /** Returns a stream reading an existing file. */
  @Override
  public IndexInput openInput(String name, IOContext context) throws IOException {
    ensureOpen();
    RAMFile file = fileMap.get(name);
    if (file == null) {
      throw new FileNotFoundException(name);
    }
    return new RAMInputStream(name, file);
  }

  /** Closes the store to future operations, releasing associated memory. */
  @Override
  public void close() {
    isOpen = false;
    fileMap.clear();
  }
}
</code></pre>

<p><code>RAMFile</code> represents a file in RAM as a list of <code>byte[]</code> buffers.</p>

<pre><code class="language-java">public class RAMFile implements Accountable {
  protected final ArrayList&lt;byte[]&gt; buffers = new ArrayList&lt;&gt;();
  long length;
  RAMDirectory directory;
  protected long sizeInBytes;

  RAMFile(RAMDirectory directory) {
    this.directory = directory;
  }
  
  protected final byte[] addBuffer(int size) {
    byte[] buffer = newBuffer(size);
    synchronized(this) {
      buffers.add(buffer);
      sizeInBytes += size;
    }

    if (directory != null) {
      directory.sizeInBytes.getAndAdd(size);
    }
    return buffer;
  }

  protected final synchronized byte[] getBuffer(int index) {
    return buffers.get(index);
  }

  protected final synchronized int numBuffers() {
    return buffers.size();
  }

  /**
   * Expert: allocate a new buffer. 
   * Subclasses can allocate differently. 
   */
  protected byte[] newBuffer(int size) {
    return new byte[size];
  }
}
</code></pre>

<h2 id="fsdirectory">FSDirectory</h2>

<p><code>FSDirectory</code> is another base class for <code>Directory</code> implementation that store index files in the file system.</p>

<pre><code class="language-java">public abstract class FSDirectory extends BaseDirectory {
  protected final Path directory; // The underlying filesystem directory

  protected FSDirectory(Path path, LockFactory lockFactory) throws IOException {
    super(lockFactory);
    // If only read access is permitted, createDirectories fails even if the directory already exists.
    if (!Files.isDirectory(path)) {
      Files.createDirectories(path);  // create directory, if it doesn't exist
    }
    directory = path.toRealPath();
  }

  /** Just like {@link #open(Path)}, but allows you to
   *  also specify a custom {@link LockFactory}. */
  public static FSDirectory open(Path path, LockFactory lockFactory) throws IOException {
    if (Constants.JRE_IS_64BIT &amp;&amp; MMapDirectory.UNMAP_SUPPORTED) {
      return new MMapDirectory(path, lockFactory);
    } else if (Constants.WINDOWS) {
      return new SimpleFSDirectory(path, lockFactory);
    } else {
      return new NIOFSDirectory(path, lockFactory);
    }
  }

  private static String[] listAll(Path dir, Set&lt;String&gt; skipNames) throws IOException {
    List&lt;String&gt; entries = new ArrayList&lt;&gt;();
    
    try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) {
      for (Path path : stream) {
        String name = path.getFileName().toString();
        if (skipNames == null || skipNames.contains(name) == false) {
          entries.add(name);
        }
      }
    }

    String[] array = entries.toArray(new String[entries.size()]);
    // Directory.listAll javadocs state that we sort the results here, so we don't let filesystem
    // specifics leak out of this abstraction:
    Arrays.sort(array);
    return array;
  }
}
</code></pre>

<p>In <code>FSDirectory</code>, a nested <code>FSIndexOutput</code> is responsible for index output.</p>

<pre><code class="language-java">final class FSIndexOutput extends OutputStreamIndexOutput {
  static final int CHUNK_SIZE = 8192;
  
  FSIndexOutput(String name, OpenOption... options) throws IOException {
    super(&quot;FSIndexOutput(path=\&quot;&quot; + directory.resolve(name) + &quot;\&quot;)&quot;, name, new FilterOutputStream(Files.newOutputStream(directory.resolve(name), options)) {
      // This implementation ensures, that we never write more than CHUNK_SIZE bytes:
      @Override
      public void write(byte[] b, int offset, int length) throws IOException {
        while (length &gt; 0) {
          final int chunk = Math.min(length, CHUNK_SIZE);
          out.write(b, offset, chunk);
          length -= chunk;
          offset += chunk;
        }
      }
    }, CHUNK_SIZE);
  }
}
</code></pre>

<p>Since <code>FSDirectory</code> is abstract, There are currently three core subclasses that can be instantiated:</p>

<ol>
<li><code>SimpleFSDirectory</code>, a straightforward implementation using Files.newByteChannel. However, it has poor concurrent performance (multiple threads will bottleneck) as it synchronizes when multiple threads read from the same file.</li>
<li><code>NIOFSDirectory</code>, uses java.nio&rsquo;s FileChannel&rsquo;s positional io when reading to avoid synchronization when reading from the same file.</li>
<li><code>MMapDirectory</code>, uses memory-mapped IO when reading. This is a good choice if you have plenty of virtual memory relative to your index size.</li>
</ol>

<h1 id="indexinput">IndexInput</h1>

<p><code>IndexInput</code> extends <code>DataInput</code>, abstract base class for performing read operations of Lucene&rsquo;s low-level data types. which provides:</p>

<pre><code class="language-java">public void readBytes(byte[] b, int offset, int len, boolean useBuffer) throws IOException;
public short readShort() throws IOException;
public int readInt() throws IOException;
public String readString() throws IOException;
public void skipBytes(final long numBytes) throws IOException;
</code></pre>

<p><code>IndexInput</code> is an abstract base class for input from a file in <code>Directory</code>. It&rsquo;s a random-access input stream, for all Lucene index input operations.</p>

<pre><code class="language-java">public abstract class IndexInput extends DataInput implements Cloneable,Closeable {
  // Returns the current position in this file
  public abstract long getFilePointer();

  // Sets current position in this file
  public abstract void seek(long pos) throws IOException;

  // Creates a slice of this index input, with the given description, offset, and length
  public abstract IndexInput slice(String sliceDescription, long offset, long length) throws IOException;

  // Creates a random-access slice of this index input, with the given offset and length
   public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException;
}
</code></pre>

<h2 id="bufferedindexinput">BufferedIndexInput</h2>

<p><code>BufferedIndexInput</code> is a implementation class for buffered <code>InputInput</code>, it also implemenets <code>RandomAccessInput</code> interface.</p>

<pre><code class="language-java">/** 
 * Random Access Index API.
 * Unlike {@link IndexInput}, this has no concept of file position, all reads
 * are absolute. However, like IndexInput, it is only intended for use by a single thread.
 */
public interface RandomAccessInput {
  public byte readByte(long pos) throws IOException;
  public short readShort(long pos) throws IOException;
  public int readInt(long pos) throws IOException;
}
</code></pre>

<p>The subclasses of <code>FSDirectory</code> has its own nested <code>XXXIndexInput</code> which extends <code>BufferedIndexInput</code>. So we must make out what it does.</p>

<pre><code class="language-java">public abstract class BufferedIndexInput extends IndexInput implements RandomAccessInput {
  protected byte[] buffer;
  
  private long bufferStart = 0;       // position in file of buffer
  private int bufferLength = 0;       // end of valid bytes
  private int bufferPosition = 0;     // next byte to read

  /** Change the buffer size used by this IndexInput */
  public final void setBufferSize(int newSize) {
    assert buffer == null || bufferSize == buffer.length: &quot;buffer=&quot; + buffer + &quot; bufferSize=&quot; + bufferSize + &quot; buffer.length=&quot; + (buffer != null ? buffer.length : 0);
    if (newSize != bufferSize) {
      checkBufferSize(newSize);
      bufferSize = newSize;
      if (buffer != null) {
        // Resize the existing buffer and carefully save as
        // many bytes as possible starting from the current
        // bufferPosition
        byte[] newBuffer = new byte[newSize];
        final int leftInBuffer = bufferLength-bufferPosition;
        final int numToCopy;
        if (leftInBuffer &gt; newSize)
          numToCopy = newSize;
        else
          numToCopy = leftInBuffer;
        System.arraycopy(buffer, bufferPosition, newBuffer, 0, numToCopy);
        bufferStart += bufferPosition;
        bufferPosition = 0;
        bufferLength = numToCopy;
        newBuffer(newBuffer);
      }
    }
  }

  private void checkBufferSize(int bufferSize) {
    if (bufferSize &lt; MIN_BUFFER_SIZE)
      throw new IllegalArgumentException(&quot;bufferSize must be at least MIN_BUFFER_SIZE (got &quot; + bufferSize + &quot;)&quot;);
  }

  @Override
  public final void readBytes(byte[] b, int offset, int len, boolean useBuffer) throws IOException {
    int available = bufferLength - bufferPosition;
    if(len &lt;= available){
      // the buffer contains enough data to satisfy this request
      if(len&gt;0) // to allow b to be null if len is 0...
        System.arraycopy(buffer, bufferPosition, b, offset, len);
      bufferPosition+=len;
    } else {
      // the buffer does not have enough data. First serve all we've got.
      if(available &gt; 0){
        System.arraycopy(buffer, bufferPosition, b, offset, available);
        offset += available;
        len -= available;
        bufferPosition += available;
      }
      // and now, read the remaining 'len' bytes:
      if (useBuffer &amp;&amp; len&lt;bufferSize){
        // If the amount left to read is small enough, and
        // we are allowed to use our buffer, do it in the usual
        // buffered way: fill the buffer and copy from it:
        refill();
        if(bufferLength&lt;len){
          // Throw an exception when refill() could not read len bytes:
          System.arraycopy(buffer, 0, b, offset, bufferLength);
          throw new EOFException(&quot;read past EOF: &quot; + this);
        } else {
          System.arraycopy(buffer, 0, b, offset, len);
          bufferPosition=len;
        }
      } else {
        // The amount left to read is larger than the buffer
        // or we've been asked to not use our buffer -
        // there's no performance reason not to read it all
        // at once. Note that unlike the previous code of
        // this function, there is no need to do a seek
        // here, because there's no need to reread what we
        // had in the buffer.
        long after = bufferStart+bufferPosition+len;
        if(after &gt; length())
          throw new EOFException(&quot;read past EOF: &quot; + this);
        readInternal(b, offset, len);
        bufferStart = after;
        bufferPosition = 0;
        bufferLength = 0;                    // trigger refill() on read
      }
    }
  }

  @Override
  public final short readShort() throws IOException {
    if (2 &lt;= (bufferLength-bufferPosition)) {
      return (short) (((buffer[bufferPosition++] &amp; 0xFF) &lt;&lt;  8) |  (buffer[bufferPosition++] &amp; 0xFF));
    } else {
      return super.readShort();
    }
  }
}
</code></pre>

<p><code>readInt</code>, <code>readLong</code> and so on, similar with <code>readShort</code>, read data from <code>buffer</code> array and convert to target type with bit operation.</p>

<h1 id="indexoutput">IndexOutput</h1>

<p><code>IndexOutput</code> extends <code>DataOutput</code>, an abstract base class for performing write operations of Lucene&rsquo;s low-level data types.</p>

<pre><code class="language-java">public abstract class DataOutput {
  public abstract void writeByte(byte b) throws IOException;
  public void writeInt(int i) throws IOException {
    writeByte((byte)(i &gt;&gt; 24));
    writeByte((byte)(i &gt;&gt; 16));
    writeByte((byte)(i &gt;&gt;  8));
    writeByte((byte) i);
  }
}
</code></pre>

<p>Derived from <code>DataOutput</code>, <code>IndexOutput</code> outputs a file in <code>Directory</code>, which is used for all Lucene index output operations.</p>

<pre><code class="language-java">public abstract class IndexOutput extends DataOutput implements Closeable {
  // Returns the current position in this file, where the next write will occur.
  public abstract long getFilePointer();
}
</code></pre>

<h2 id="ramoutputstream">RAMOutputStream</h2>

<p>Eash subclass of <code>Directory</code> has corresponding <code>IndexOutput</code> implementation, for example, <code>RAMDirecotry</code> and <code>RAMOutputStream</code>.</p>

<pre><code class="language-java">public class RAMOutputStream extends IndexOutput implements Accountable {
  private final RAMFile file;

  private byte[] currentBuffer;
  private int currentBufferIndex;
  
  private int bufferPosition;
  private long bufferStart;
  private int bufferLength;

  /** Copy the current contents of this buffer to the provided {@link DataOutput}. */
  public void writeTo(DataOutput out) throws IOException {
    flush();
    final long end = file.length;
    long pos = 0;
    int buffer = 0;
    while (pos &lt; end) {
      int length = BUFFER_SIZE;
      long nextPos = pos + length;
      if (nextPos &gt; end) {                        // at the last buffer
        length = (int)(end - pos);
      }
      out.writeBytes(file.getBuffer(buffer++), length);
      pos = nextPos;
    }
  }

  @Override
  public void writeByte(byte b) throws IOException {
    if (bufferPosition == bufferLength) {
      currentBufferIndex++;
      switchCurrentBuffer();
    }
    if (crc != null) {
      crc.update(b);
    }
    currentBuffer[bufferPosition++] = b;
  }

  @Override
  public long getFilePointer() {
    return currentBufferIndex &lt; 0 ? 0 : bufferStart + bufferPosition;
  }
}
</code></pre>

<p><strong>Reference</strong></p>

<ul>
<li><a href="https://lucene.apache.org/core/6_4_2/core/org/apache/lucene/store/Directory.html">Directory</a></li>
<li><a href="https://www.tutorialspoint.com/lucene/lucene_directory.htm">Lucene Directory - TutorialsPoint</a></li>
</ul>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="https://hellokangning.github.io/tags/lucene/">Lucene</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="https://hellokangning.github.io/post/how-does-client-find-the-region/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How Does Client Find the Region</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="https://hellokangning.github.io/post/when-finally-really-executes/">
            <span class="next-text nav-default">When finally Really Executes</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
  <a href="https://hellokangning.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="https://hellokangning.github.io/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="https://hellokangning.github.io/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="https://hellokangning.github.io/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="https://hellokangning.github.io/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="https://hellokangning.github.io/dist/even.min.js?v=3.2.0"></script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-105833321-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
