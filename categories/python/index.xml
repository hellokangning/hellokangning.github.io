<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Guoqing Geng</title>
    <link>https://hellokangning.github.io/categories/python/</link>
    <description>Recent content in Python on Guoqing Geng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Sep 2017 19:36:07 +0800</lastBuildDate>
    
	<atom:link href="https://hellokangning.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Understanding Python Decorator</title>
      <link>https://hellokangning.github.io/post/understanding-python-decorator/</link>
      <pubDate>Wed, 20 Sep 2017 19:36:07 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/understanding-python-decorator/</guid>
      <description>&lt;p&gt;A Python decorator, similar with &lt;a href=&#34;http://en.wikipedia.org/wiki/Decorator_pattern&#34;&gt;Decorator Parttern&lt;/a&gt;, is a specific change to the Python syntax that allows us to more conveniently alter functions and methods. In this post, I will try my best to deep into this advanced feature in Python.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>*args and **kwargs Usage in Python</title>
      <link>https://hellokangning.github.io/post/args-and-kwargs-usage-in-python/</link>
      <pubDate>Fri, 08 Sep 2017 16:46:50 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/args-and-kwargs-usage-in-python/</guid>
      <description>&lt;p&gt;The &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; is a common idiom to allow arbitrary number of arguments to functions as described in the section more on &lt;a href=&#34;https://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions&#34;&gt;defining functions&lt;/a&gt; in the Python documentation.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>When finally Really Executes</title>
      <link>https://hellokangning.github.io/post/when-finally-really-executes/</link>
      <pubDate>Mon, 04 Sep 2017 16:22:03 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/when-finally-really-executes/</guid>
      <description>&lt;p&gt;Epitome:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;return doesn&amp;rsquo;t really return, it pushs value to stack, then jumps to finally, which was set up by &lt;code&gt;SETUP_FINALLY&lt;/code&gt; before.&lt;/li&gt;
&lt;li&gt;after executing finally, &lt;code&gt;END_FINALLY&lt;/code&gt; returns.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exit Options in Python</title>
      <link>https://hellokangning.github.io/post/exit-options-in-python/</link>
      <pubDate>Fri, 01 Sep 2017 16:47:37 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/exit-options-in-python/</guid>
      <description>First candidate is os._exit, which exits without calling cleanup handlers, flushing stdio buffers, etc. (and which should normally only be used in the child process after a fork()).
Second, sys.exit is intended for use in programs. According to official document:
 This is implemented by raising the SystemExit exception, so cleanup actions specified by finally clauses of try statements are honored, and it is possible to intercept the exit attempt at an outer level.</description>
    </item>
    
    <item>
      <title>The Difference between range and xrange</title>
      <link>https://hellokangning.github.io/post/difference-between-range-and-xrange/</link>
      <pubDate>Fri, 01 Sep 2017 16:22:27 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/difference-between-range-and-xrange/</guid>
      <description>&lt;p&gt;Short answer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range&lt;/code&gt; creates a list, so if you do &lt;code&gt;range(1, 10000000)&lt;/code&gt; it creates a list in memory with 9999999 elements. This will become an expensive operation on very large ranges.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xrange&lt;/code&gt; is a sequence object that &lt;em&gt;evaluates lazily&lt;/em&gt;(it will only compute the next value when needed).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Dive into __slots__</title>
      <link>https://hellokangning.github.io/post/a-dive-into-slots/</link>
      <pubDate>Thu, 31 Aug 2017 14:25:37 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/a-dive-into-slots/</guid>
      <description>&lt;p&gt;&lt;code&gt;__slots__&lt;/code&gt; tells interpreter not to use a dict, and only allocate space for a fixed set of attributes.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pip Install ipython Exception on EI Capitan</title>
      <link>https://hellokangning.github.io/post/pip-install-ipython-exception-on-ei-capitan/</link>
      <pubDate>Thu, 03 Aug 2017 15:23:36 +0800</pubDate>
      
      <guid>https://hellokangning.github.io/post/pip-install-ipython-exception-on-ei-capitan/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;For those impatient: OS X EI Capition shipped a security feature named System Integrity Protection, which would be a hinder for &lt;code&gt;pip&lt;/code&gt;. Try to install IPython in user mode: &lt;code&gt;pip install ipython --user&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>