<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java NIO: Selector - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="Taking FileChannel for example in the previous post may bewilder audiences: it&amp;rsquo;s non-blocking, so how does NIO achievement non-blocking? Here comes Selector.
A Selector is a Java NIO component which can examine one or more NIO Channel&amp;rsquo;s, and determine which channels are ready for reading or writing. A thread can manage multiply channels with Selector making multiple network connections feasible. This way avoids the cost of switching between threads which is expensive.
Here is an illustration of a thread using a Selector to handle 3 Channels:

" />
<meta name="keywords" content="Java, NIO, Selector" />







<meta name="generator" content="Hugo 0.44" />


<link rel="canonical" href="https://hellokangning.github.io/en/post/java-nio-selector/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Java NIO: Selector" />
<meta property="og:description" content="Taking FileChannel for example in the previous post may bewilder audiences: it&rsquo;s non-blocking, so how does NIO achievement non-blocking? Here comes Selector.

A Selector is a Java NIO component which can examine one or more NIO Channel&rsquo;s, and determine which channels are ready for reading or writing. A thread can manage multiply channels with Selector making multiple network connections feasible. This way avoids the cost of switching between threads which is expensive.

Here is an illustration of a thread using a Selector to handle 3 Channels:



" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/en/post/java-nio-selector/" />



<meta property="article:published_time" content="2018-07-21T17:54:50&#43;08:00"/>

<meta property="article:modified_time" content="2018-07-21T17:54:50&#43;08:00"/>











<meta itemprop="name" content="Java NIO: Selector">
<meta itemprop="description" content="Taking FileChannel for example in the previous post may bewilder audiences: it&rsquo;s non-blocking, so how does NIO achievement non-blocking? Here comes Selector.

A Selector is a Java NIO component which can examine one or more NIO Channel&rsquo;s, and determine which channels are ready for reading or writing. A thread can manage multiply channels with Selector making multiple network connections feasible. This way avoids the cost of switching between threads which is expensive.

Here is an illustration of a thread using a Selector to handle 3 Channels:



">


<meta itemprop="datePublished" content="2018-07-21T17:54:50&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-21T17:54:50&#43;08:00" />
<meta itemprop="wordCount" content="1784">



<meta itemprop="keywords" content="java.nio," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java NIO: Selector"/>
<meta name="twitter:description" content="Taking FileChannel for example in the previous post may bewilder audiences: it&rsquo;s non-blocking, so how does NIO achievement non-blocking? Here comes Selector.

A Selector is a Java NIO component which can examine one or more NIO Channel&rsquo;s, and determine which channels are ready for reading or writing. A thread can manage multiply channels with Selector making multiple network connections feasible. This way avoids the cost of switching between threads which is expensive.

Here is an illustration of a thread using a Selector to handle 3 Channels:



"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/en/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/en/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/en/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/en/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/en/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/zh/">
        <li class="mobile-menu-item">中文</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/en/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/en/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/zh/">中文</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java NIO: Selector</h1>

      <div class="post-meta">
        <span class="post-time"> Jul 21, 2018 </span>
        <div class="post-category">
            
              <a href="/en/categories/java/"> Java </a>
            
          </div>
        <span class="more-meta"> 1784 words </span>
        <span class="more-meta"> 4 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#creating-a-selector">Creating a Selector</a></li>
<li><a href="#registering-channels-with-the-selector">Registering Channels with the Selector</a></li>
<li><a href="#selectionkey">SelectionKey</a>
<ul>
<li><a href="#interest-set">Interest Set</a></li>
<li><a href="#ready-set">Ready Set</a></li>
<li><a href="#channel-selector">Channel + Selector</a></li>
<li><a href="#attaching-objects">Attaching Objects</a></li>
</ul></li>
<li><a href="#selecting-channels-via-a-selector">Selecting Channels via a Selector</a>
<ul>
<li><a href="#selectedkeys"><code>selectedKeys()</code></a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>Taking FileChannel for example in the <a href="https://hellokangning.github.io/post/java-nio-channel/">previous post</a> may bewilder audiences: it&rsquo;s non-blocking, so how does NIO achievement non-blocking? Here comes Selector.</p>

<p>A Selector is a Java NIO component which can examine one or more NIO Channel&rsquo;s, and determine which channels are ready for reading or writing. A thread can manage multiply channels with Selector making multiple network connections feasible. This way avoids the cost of switching between threads which is expensive.</p>

<p>Here is an illustration of a thread using a Selector to handle 3 Channels:</p>

<p><img src="/images/java-nio-selector-handle-channels.png" alt="" /></p>

<p></p>

<h1 id="creating-a-selector">Creating a Selector</h1>

<p>You create a Selector by calling the Selector.open() method, like this: <code>Selector selector = Selector.open();</code>.</p>

<p>Loot at the multilevel inheritance hierarchy.</p>

<p><img src="/images/java-nio-selector-class.png" alt="" /></p>

<p>Selector, even an abstract class, implements <code>open()</code> method to open a selector. The new selector is created by invoking <code>SelectorProvider#openSelector</code> method.</p>

<pre><code>// Selector.java

public abstract class Selector implements Closeable {
    public static Selector open() throws IOException {
        return SelectorProvider.provider().openSelector();
    }
}
</code></pre>

<p>Regarding to <code>SelectorProvider#openSelector</code>, is also abstract, but instantiates a system-default provider class.</p>

<pre><code class="language-java">// SelectorProvider.java

public abstract class SelectorProvider {
    private static SelectorProvider provider = null;

    public abstract AbstractSelector openSelector()
        throws IOException;

    public static SelectorProvider provider() {
        synchronized (lock) {
            if (provider != null)
                return provider;
            return AccessController.doPrivileged(
                new PrivilegedAction&lt;SelectorProvider&gt;() {
                    public SelectorProvider run() {
                            if (loadProviderFromProperty())
                                return provider;
                            if (loadProviderAsService())
                                return provider;
                            provider = sun.nio.ch.DefaultSelectorProvider.create();
                            return provider;
                        }
                    });
        }
    }
}
</code></pre>

<p>For Linux, it&rsquo;s EpollSelectorProvider.</p>

<pre><code class="language-java">// DefaultSelectorProvider.java

public class DefaultSelectorProvider {

    /**
     * Prevent instantiation.
     */
    private DefaultSelectorProvider() { }

    /**
     * Returns the default SelectorProvider.
     */
    public static SelectorProvider create() {
        return new EPollSelectorProvider();
    }
}
</code></pre>

<h1 id="registering-channels-with-the-selector">Registering Channels with the Selector</h1>

<p>Before you use a Channel with a Selector, you must register the Channel with the Selector. Calling <code>SelectableChannel.register()</code> method can attain that.</p>

<pre><code class="language-java">channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
</code></pre>

<p>Only SelectableChannel can register with Selector, and the children of SelectableChannel must implement <code>configureBlocking</code>, which excludes FileChannel.</p>

<p>AbstractSelectableChannel, the child of SelectableChannel implements <code>register()</code> method by the following steps:</p>

<ul>
<li>get the lock</li>
<li>check if this channel is open</li>
<li>check whether or not the events you want to listen for is valid</li>
<li>check if this channel is in blocking mode</li>
<li>check if thew keys have been created</li>
<li>call <code>AbstractSelector#register</code> method</li>
</ul>

<pre><code class="language-java">// AbstractSelectableChannel.java

public final SelectionKey register(Selector sel, int ops,
                                   Object att)
    throws ClosedChannelException
{
    synchronized (regLock) {
        if (!isOpen())
            throw new ClosedChannelException();
        if ((ops &amp; ~validOps()) != 0)
            throw new IllegalArgumentException();
        if (blocking)
            throw new IllegalBlockingModeException();
        SelectionKey k = findKey(sel);
        if (k != null) {
            k.interestOps(ops);
            k.attach(att);
        }
        if (k == null) {
            // New registration
            synchronized (keyLock) {
                if (!isOpen())
                    throw new ClosedChannelException();
                k = ((AbstractSelector)sel).register(this, ops, att);
                addKey(k);
            }
        }
        return k;
    }
}
</code></pre>

<p>As to <code>AbstractSelector#register</code>, SelectorImpl derived from AbstractSelector implements the <code>register</code> method but leaves central work to an abstract method <code>impleRegister</code>.</p>

<pre><code class="language-java">// SelectorImpl.java

protected final SelectionKey register(AbstractSelectableChannel ch,
                                      int ops,
                                      Object attachment)
{
    if (!(ch instanceof SelChImpl))
        throw new IllegalSelectorException();
    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
    k.attach(attachment);
    synchronized (publicKeys) {
        implRegister(k);
    }
    k.interestOps(ops);
    return k;
}

protected abstract void implRegister(SelectionKeyImpl ski);
</code></pre>

<p>EPollSelectorImpl, the offspring of SelectorImpl fills <code>impleRegister</code>. Few member variables invloved include:</p>

<ul>
<li>closed: True if this Selector has been closed</li>
<li>fdToKey: Maps from file descriptors to keys</li>
<li>pollWrapper: The poll object</li>
</ul>

<pre><code class="language-java">// EPollSelectorImpl.java

class EPollSelectorImpl
    extends SelectorImpl
{
    private volatile boolean closed;
    private Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;
    EPollArrayWrapper pollWrapper;


    protected void implRegister(SelectionKeyImpl ski) {
        if (closed)
            throw new ClosedSelectorException();
        SelChImpl ch = ski.channel;
        int fd = Integer.valueOf(ch.getFDVal());
        fdToKey.put(fd, ski);
        pollWrapper.add(fd);
        keys.add(ski);
    }
}
</code></pre>

<p>Notice the second parameter of the <code>register()</code> method. This is an &ldquo;interest set&rdquo;, meaning what events you are interested in listening for in the Channel, via the Selector. There are four different events you can listen for and represented by the four SelectionKey constants:</p>

<table>
<thead>
<tr>
<th>Event</th>
<th>SelecttionKey constant</th>
</tr>
</thead>

<tbody>
<tr>
<td>Connect</td>
<td>SelectionKey.OP_CONNECT</td>
</tr>

<tr>
<td>Accept</td>
<td>SelectionKey.OP_ACCEPT</td>
</tr>

<tr>
<td>Read</td>
<td>SelectionKey.OP_READ</td>
</tr>

<tr>
<td>Write</td>
<td>SelectionKey.OP_WRITE</td>
</tr>
</tbody>
</table>

<h1 id="selectionkey">SelectionKey</h1>

<p>When you register a channel with a <code>Selector</code> the <code>Channel.register()</code> method returns a <code>SelectionKey</code>object. This key represents that channels registration with that selector.</p>

<p>This <code>SelectionKey</code> object contains a few interesting properties:</p>

<ul>
<li>The interest set</li>
<li>The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>An attached object (optional)</li>
</ul>

<h2 id="interest-set">Interest Set</h2>

<p>The interest set determines which operation categories will be tested for readiness the next time one of the selector&rsquo;s selection methods is invoked.  The interest set is initialized with the value given when the key is created; it may later be changed via the <code>interestOps(int)</code> method or retrieves via the <code>interestOps()</code>.</p>

<pre><code class="language-java">// SelectionKey.java

public abstract class SelectionKey {
  public abstract int interestOps();
  public abstract SelectionKey interestOps(int ops);
}
</code></pre>

<p>you can AND the interest set with the given <code>SelectionKey</code> constant to find out if a certain event is in the interest set.</p>

<pre><code class="language-java">int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;  
</code></pre>

<p>The implementation of <code>interestOps</code> lies in SelectionKeyImpl.</p>

<pre><code class="language-java">// SelectionKeyImpl.java

public class SelectionKeyImpl
    extends AbstractSelectionKey
{
	final SelChImpl channel; 
    private volatile int interestOps;
    
    private void ensureValid() {
        if (!isValid())
            throw new CancelledKeyException();
    }
    
    public int interestOps() {
        ensureValid();
        return interestOps;
    }

    public SelectionKey interestOps(int ops) {
        ensureValid();
        return nioInterestOps(ops);
    }
    
    public SelectionKey nioInterestOps(int ops) {
        if ((ops &amp; ~channel().validOps()) != 0)
            throw new IllegalArgumentException();
        channel.translateAndSetInterestOps(ops, this);
        interestOps = ops;
        return this;
    }
}
</code></pre>

<p>The child of Channel, SocketChannelImpl here, translates native poll revent ops into a ready operation ops with <code>SocketChannelImpl#translateAndSetInterestOps</code> method.</p>

<h2 id="ready-set">Ready Set</h2>

<p>The ready set identifies the operation categories for which the key&rsquo;s channel has been detected to be ready by the key&rsquo;s selector. The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.</p>

<p>The <code>readyOps()</code> method in SelectionKey opens the door to retrieve this key&rsquo;s ready-operation set.</p>

<pre><code class="language-java">// SelectionKey.java

public abstract class SelectionKey {
    public abstract int readyOps();
}
</code></pre>

<p>You can test in the same way as with the interest set, what events / operations the channel is ready for. But, you can also use these four methods instead, which all reaturn a boolean:</p>

<pre><code>selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
</code></pre>

<h2 id="channel-selector">Channel + Selector</h2>

<p>Accessing the channel + selector from the <code>SelectionKey</code> is trivial. Here is how it&rsquo;s done:</p>

<pre><code>Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();  
</code></pre>

<p>Remember the structure of SelectionKeyImpl? It has a package-private member named <code>channel</code> and  a public one <code>selector</code>.</p>

<pre><code class="language-java">// SelectionKeyImpl.java

public class SelectionKeyImpl
    extends AbstractSelectionKey
{
	final SelChImpl channel;                            // package-private
	public final SelectorImpl selector;
	
	public SelectableChannel channel() {
        return (SelectableChannel)channel;
    }
    
    public Selector selector() {
        return selector;
    }
}
</code></pre>

<h2 id="attaching-objects">Attaching Objects</h2>

<p>You can attach an object to a SelectionKey providing a handy way of recognizing a given channel.</p>

<p>Here is how you attach objects:</p>

<pre><code class="language-java">selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
</code></pre>

<p>AtomicReferenceFieldUpdater, a reflection-based utility, is engaged in to that enable atomic updates to designated volatile reference fields of designated classes.</p>

<pre><code class="language-java">// SelectionKey.java
    
public abstract class SelectionKey {    
    private volatile Object attachment = null;
    private static final AtomicReferenceFieldUpdater&lt;SelectionKey,Object&gt;
        attachmentUpdater = AtomicReferenceFieldUpdater.newUpdater(
            SelectionKey.class, Object.class, &quot;attachment&quot;
        );

    public final Object attach(Object ob) {
        return attachmentUpdater.getAndSet(this, ob);
    }

    public final Object attachment() {
        return attachment;
    }
}
</code></pre>

<h1 id="selecting-channels-via-a-selector">Selecting Channels via a Selector</h1>

<p>Once you have registered one or more channels with a Selector, you can call one of the <code>select()</code> methods.  These methods select a set of keys whose corresponding channels are ready for I/O perations(connect, accept, read or write).</p>

<p>Here are the select() methods:</p>

<ul>
<li><code>int select()</code> performs a blocking selection operation. It returns only after at least one channel is selected, this selector&rsquo;s <code>wakeup</code> method is invoked, or the current thread is interrupted, whichever comes first.</li>
<li><code>int select(long timeout)</code> does the same as <code>select()</code> except it blocks for a maximum of timeout milliseconds.</li>
<li><code>int selectNow()</code> performs a non-blocking selection operation.  If no channels have become selectable since the previous selection operation then this method immediately returns zero. Invoking this method clears the effect of any previous invocations of the <code>wakeup</code> method.</li>
</ul>

<pre><code class="language-java">// SelectorImpl.java

public abstract class SelectorImpl
    extends AbstractSelector
{
    protected abstract int doSelect(long timeout) throws IOException;

    public int select(long timeout)
        throws IOException
    {
        if (timeout &lt; 0)
            throw new IllegalArgumentException(&quot;Negative timeout&quot;);
        return lockAndDoSelect((timeout == 0) ? -1 : timeout);
    }

    public int select() throws IOException {
        return select(0);
    }

    public int selectNow() throws IOException {
        return lockAndDoSelect(0);
    }

    private int lockAndDoSelect(long timeout) throws IOException {
        synchronized (this) {
            if (!isOpen())
                throw new ClosedSelectorException();
            synchronized (publicKeys) {
                synchronized (publicSelectedKeys) {
                    return doSelect(timeout);
                }
            }
        }
    }
}
</code></pre>

<p>SelectorImpl leaves <code>doSelect(long)</code> unimplemented to its derived class. Let&rsquo;s see what EPollSelectorImpl does.</p>

<pre><code class="language-java">// EPollSelectorImpl.java

class EPollSelectorImpl
    extends SelectorImpl
{
    protected int doSelect(long timeout) throws IOException {
        if (closed)
            throw new ClosedSelectorException();
        processDeregisterQueue();
        try {
            begin();
            pollWrapper.poll(timeout);
        } finally {
            end();
        }
        processDeregisterQueue();
        int numKeysUpdated = updateSelectedKeys();
        if (pollWrapper.interrupted()) {
            // Clear the wakeup pipe
            pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);
            synchronized (interruptLock) {
                pollWrapper.clearInterrupted();
                IOUtil.drain(fd0);
                interruptTriggered = false;
            }
        }
        return numKeysUpdated;
    }
}
</code></pre>

<p>EPollSelectorImpl appeals to EPollArrayWrapper who manipulates a native array of <code>epoll_event</code> structs on Linux. The int returned by the <code>select()</code> methods tells how many channels are ready.</p>

<h2 id="selectedkeys"><code>selectedKeys()</code></h2>

<p>Once you have called one of the <code>select()</code> methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the &ldquo;selected key set&rdquo;, by calling the selectors selectedKeys() method. Here is how that looks:</p>

<pre><code class="language-java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();  
</code></pre>

<p>The implementation of <code>selectedKeys()</code> is in SelectorImpl using a Set named <code>publicSelectedKeys</code> to store keys that are going to be selected.</p>

<pre><code class="language-java">// SelectorImpl.java

public abstract class SelectorImpl
    extends AbstractSelector
{
    private Set&lt;SelectionKey&gt; publicKeys;             // Immutable
    private Set&lt;SelectionKey&gt; publicSelectedKeys;     // Removal allowed, but not addition

    public Set&lt;SelectionKey&gt; selectedKeys() {
        if (!isOpen() &amp;&amp; !Util.atBugLevel(&quot;1.4&quot;))
            throw new ClosedSelectorException();
        return publicSelectedKeys;
    }
}
</code></pre>

<p>When you register a channel with a Selector the <code>Channel.register()</code> method returns a SelectionKey object. This key represents that channels registration with that selector. It is these keys you can access via the <code>selectedKeySet()</code>method from the SelectionKey.</p>

<p>You can iterate this selected key set to access the ready channels. Here is how that looks:</p>

<pre><code class="language-java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {
    
    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}
</code></pre>

<p>Notice the <code>keyIterator.remove()</code> call at the end of each iteration. The Selector does not remove the SelectionKey instances from the selected key set itself. You have to do this, when you are done processing the channel. The next time the channel becomes &ldquo;ready&rdquo; the Selector will add it to the selected key set again.</p>

<p><strong>Reference</strong></p>

<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li>
<li><a href="https://www.javacodegeeks.com/2018/07/java-nio-tutorial.html">Java NIO Tutorial</a></li>
<li><a href="https://juejin.im/post/5af942c6f265da0b7026050c">nio你了解多少？</a></li>
</ul>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/en/tags/java.nio/">java.nio</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/en/post/binary-search-for-upper-bound/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Binary Search for Upper Bound</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/en/post/java-nio-channel/">
            <span class="next-text nav-default">Java NIO: Channel</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
  <a href="https://hellokangning.github.io/en/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-105833321-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
