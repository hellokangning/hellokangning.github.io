<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java NIO: Buffer - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="Java NIO (New IO), introduced by Java 1.4, is an alternative IO API for Java. It offers a different way of working with IO than the standard IO API&amp;rsquo;s.
Three core components of Java NIO cover:
 Channels Buffers Selectors  All IO in NIO involves with Channel. Data can be read from Channel to a Buffer and vice versa.
Buffers are used to interact with Channels. A Buffer is an allocated block of memory with fixed size, into which you can read or write data. In this post, I&amp;rsquo;ll illustrate the basic usage of Buffer and elucidate how it manages to do that from the view of source code.

" />
<meta name="keywords" content="Java, NIO, Buffer" />







<meta name="generator" content="Hugo 0.44" />


<link rel="canonical" href="https://hellokangning.github.io/en/post/java-nio-buffer/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Java NIO: Buffer" />
<meta property="og:description" content="Java NIO (New IO), introduced by Java 1.4, is an alternative IO API for Java. It offers a different way of working with IO than the standard IO API&rsquo;s.

Three core components of Java NIO cover:


Channels
Buffers
Selectors


All IO in NIO involves with Channel. Data can be read from Channel to a Buffer and vice versa.



Buffers are used to interact with Channels. A Buffer is an allocated block of memory with fixed size, into which you can read or write data. In this post, I&rsquo;ll illustrate the basic usage of Buffer and elucidate how it manages to do that from the view of source code.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/en/post/java-nio-buffer/" />



<meta property="article:published_time" content="2018-07-14T17:00:53&#43;08:00"/>

<meta property="article:modified_time" content="2018-07-14T17:00:53&#43;08:00"/>











<meta itemprop="name" content="Java NIO: Buffer">
<meta itemprop="description" content="Java NIO (New IO), introduced by Java 1.4, is an alternative IO API for Java. It offers a different way of working with IO than the standard IO API&rsquo;s.

Three core components of Java NIO cover:


Channels
Buffers
Selectors


All IO in NIO involves with Channel. Data can be read from Channel to a Buffer and vice versa.



Buffers are used to interact with Channels. A Buffer is an allocated block of memory with fixed size, into which you can read or write data. In this post, I&rsquo;ll illustrate the basic usage of Buffer and elucidate how it manages to do that from the view of source code.

">


<meta itemprop="datePublished" content="2018-07-14T17:00:53&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-14T17:00:53&#43;08:00" />
<meta itemprop="wordCount" content="1342">



<meta itemprop="keywords" content="java.nio," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java NIO: Buffer"/>
<meta name="twitter:description" content="Java NIO (New IO), introduced by Java 1.4, is an alternative IO API for Java. It offers a different way of working with IO than the standard IO API&rsquo;s.

Three core components of Java NIO cover:


Channels
Buffers
Selectors


All IO in NIO involves with Channel. Data can be read from Channel to a Buffer and vice versa.



Buffers are used to interact with Channels. A Buffer is an allocated block of memory with fixed size, into which you can read or write data. In this post, I&rsquo;ll illustrate the basic usage of Buffer and elucidate how it manages to do that from the view of source code.

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/en/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/en/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/en/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/en/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/en/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/zh/">
        <li class="mobile-menu-item">中文</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/en/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/en/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/zh/">中文</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java NIO: Buffer</h1>

      <div class="post-meta">
        <span class="post-time"> Jul 14, 2018 </span>
        <div class="post-category">
            
              <a href="/en/categories/java/"> Java </a>
            
          </div>
        <span class="more-meta"> 1342 words </span>
        <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#buffer-capacity-position-and-limit">Buffer Capacity, Position and Limit</a></li>
<li><a href="#allocating-a-buffer">Allocating a Buffer</a></li>
<li><a href="#writing-data-to-a-buffer">Writing Data to a Buffer</a></li>
<li><a href="#flip"><code>flip()</code></a></li>
<li><a href="#reading-data-from-a-buffer">Reading Data from a Buffer</a></li>
<li><a href="#rewind"><code>rewind()</code></a></li>
<li><a href="#clear"><code>clear()</code></a></li>
<li><a href="#mark"><code>mark</code></a></li>
<li><a href="#equals-and-compareto"><code>equals()</code> and <code>compareTo()</code></a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>Java NIO (New IO), introduced by Java 1.4, is an alternative IO API for Java. It offers a different way of working with IO than the standard IO API&rsquo;s.</p>

<p>Three core components of Java NIO cover:</p>

<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>

<p>All IO in NIO involves with Channel. Data can be read from Channel to a Buffer and vice versa.</p>

<p><img src="/images/java-nio-channel-buffer.png" alt="" /></p>

<p>Buffers are used to interact with Channels. A Buffer is an allocated block of memory with fixed size, into which you can read or write data. In this post, I&rsquo;ll illustrate the basic usage of Buffer and elucidate how it manages to do that from the view of source code.</p>

<p></p>

<p><img src="/images/java-nio-bytebuffer-class.png" alt="" /></p>

<h1 id="basic-usage">Basic Usage</h1>

<p>Using a Buffer to read and write data typically follows this little 4-step process:</p>

<ol>
<li>Write data into the Buffer</li>
<li>Call <code>buffer.flip()</code></li>
<li>Read data out of the Buffer</li>
<li>Call <code>buffer.clear()</code> or <code>buffer.compact()</code></li>
</ol>

<p>It&rsquo;s hard to understand what <code>flip()</code> does from its name. Actually, <code>flip()</code> switch the buffer from writing mode to reading mode, allowing reading all data in it.</p>

<p>After read, you need to clear the buffer so that it can be written again. Two alternative methods, <code>clear()</code> and <code>compact()</code>, are able to sweep the buffer for you. While <code>clear()</code> clears the whole buffer, <code>compact()</code> only clear the data just already read. Any unread data is moved to the beginning of buffer, after which data will be written.</p>

<pre><code class="language-java">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {

  buf.flip();  //make buffer ready for read

  while(buf.hasRemaining()){
      System.out.print((char) buf.get()); // read 1 byte at a time
  }

  buf.clear(); //make buffer ready for writing
  bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<h1 id="buffer-capacity-position-and-limit">Buffer Capacity, Position and Limit</h1>

<p>Aside from its content, the essential properties of a buffer are</p>

<ul>
<li>capacity: the number of elements it contains. The capacity of a buffer is fixed, which means it nevew changes.</li>
<li>limit: the index of the first element that should not be read or written. A limit is never greater than its capacity.</li>
<li>position: the index of the next element to be read or written. Position is always smaller that its limit.</li>
</ul>

<p><img src="/images/java-nio-buffer-mode.png" alt="" /></p>

<p>A glimpse of code supports the above statements.</p>

<pre><code class="language-java">public abstract class Buffer {
    private int position = 0;
    private int limit;
    private int capacity;
}
</code></pre>

<p>Java NIO provides various types of buffers that can be used depending on the type of input. This post will take <code>ByteBuffer</code> for simplicity.</p>

<h1 id="allocating-a-buffer">Allocating a Buffer</h1>

<p>Before you do anything on a Buffer, you need to allocate one. <code>allocate</code> method is inevitable to call.</p>

<p>The following example shows the allocation of a <code>ByteBuffer</code>, with a capacity of 48 bytes.</p>

<pre><code class="language-java">ByteBuffer buf = ByteBuffer.allocate(48);
</code></pre>

<p><code>allocate</code> in <code>ByteBuffer</code> calls the constructor of <code>HeapByteBuffer</code>, a subclass of `ByteBuffer.</p>

<pre><code class="language-java">// ByteBuffer.java

public static ByteBuffer allocate(int capacity) {
    if (capacity &lt; 0)
        throw new IllegalArgumentException();
    return new HeapByteBuffer(capacity, capacity);
}
</code></pre>

<p>A byte array with capacity of <code>cap</code> is allocated and offet is set to 0, here is a illustration.</p>

<pre><code class="language-java">hb = new byte[cap];
offset = 0;
</code></pre>

<p><code>hb</code> and <code>offset</code> are two varibles in <code>ByteBuffer</code>.</p>

<pre><code class="language-java">public abstract class ByteBuffer
    extends Buffer
    implements Comparable&lt;ByteBuffer&gt;
{
    final byte[] hb;                  // Non-null only for heap buffers
    final int offset;
}

</code></pre>

<h1 id="writing-data-to-a-buffer">Writing Data to a Buffer</h1>

<p>You can write data from a Channel to a Buffer, like</p>

<pre><code class="language-java">int bytesRead = inChannel.read(buf); //read into buffer
</code></pre>

<p>Or you can write data into Buffer yourself,</p>

<pre><code class="language-java">buf.put(127);
</code></pre>

<p>The former will be illuminated later. Let&rsquo;s check what <code>put</code> does.</p>

<pre><code class="language-java">// ByteBuffer.java

public abstract ByteBuffer put(byte b);
</code></pre>

<p><code>put</code> method is abstract in <code>ByteBuffer</code>, which means its derived class is responsible to implement it.</p>

<p>As mentioned before, <code>HeapByteBuffer</code> derives from <code>ByteBuffer</code>.</p>

<pre><code class="language-java">// HeapByteBuffer.java

class HeapByteBuffer
    extends ByteBuffer 
{
    public ByteBuffer put(byte x) {

        hb[ix(nextPutIndex())] = x;
        return this;
    }

    protected int ix(int i) {
        return i + offset;
    }

    final int nextPutIndex() {                          // package-private
        if (position &gt;= limit)
            throw new BufferOverflowException();
        return position++;
    }
}
</code></pre>

<p><code>nextPutIndex</code> returns the current position against the limit, and <code>ix</code> adds any input with <code>offset</code>. The combination of <code>nextPutIndex</code> and <code>ix</code> find the index which the newcome byte can be put into.</p>

<h1 id="flip"><code>flip()</code></h1>

<p><code>flip</code> method swithes the mode of a Buffer, from writing mode to reading.</p>

<pre><code class="language-java">// Buffer.java

public final Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
</code></pre>

<p>The code is simple, from which we can see it sets the <code>limit</code> to current position and then sets the <code>position</code> back to 0.</p>

<p>After <code>flip()</code>, <code>position</code> represents the reading point and <code>limit</code> indicates how many bytes have been written into this Buffer so that can be read.</p>

<h1 id="reading-data-from-a-buffer">Reading Data from a Buffer</h1>

<p><code>get</code> method gives a way to read data from Buffer.</p>

<pre><code class="language-java">byte aByte = buf.get();
</code></pre>

<p>Here is what <code>HeapByteBuffer</code> does.</p>

<pre><code class="language-java">// HeapByteBuffer.java

public byte get() {
    return hb[ix(nextGetIndex())];
}

final int nextGetIndex() {
    if (position &gt;= limit)
        throw new BufferUnderflowException();
    return position++;
}
</code></pre>

<p><code>nextGetIndex</code> checks the current position against the limit, and plus one after each read.</p>

<h1 id="rewind"><code>rewind()</code></h1>

<p>The <code>Buffer.rewind()</code> sets the position back to 0 and keeps <code>limit</code> intact, so you can reread all the data in the buffer.</p>

<pre><code class="language-java">// Buffer.java

public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
</code></pre>

<h1 id="clear"><code>clear()</code></h1>

<p><code>clear()</code> does not purge the Buffer, as many of you may think. It only resets <code>position</code> to 0, and <code>limit</code> to <code>capacity</code>. Any unread data will lost if you <code>clear()</code> wrongly.</p>

<pre><code class="language-java">// Buffer.java

public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
</code></pre>

<p>If you want to keep those unread data, use <code>compact()</code>. <code>compact()</code> copies all unread data to the beginning of the Buffer. Then it sets position to right after the last unread element. The limit property is still set to capacity, just like <code>clear()</code> does. Now the Buffer is ready for writing, but you will not overwrite the unread data.</p>

<pre><code class="language-java">// HeapByteBuffer.java

public ByteBuffer compact() {
    System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
    position(remaining());
    limit(capacity());
    discardMark();
    return this;
}
</code></pre>

<h1 id="mark"><code>mark</code></h1>

<p>You may notice, no matter in <code>get</code>, <code>put</code>, <code>clear</code> or <code>compact</code>, a variable <code>mark</code> is engaged. As its name reveals, you can mark a given position of Buffer if you want.</p>

<p>By calling <code>mark()</code>, current <code>position</code> is assigned to <code>mark</code>, which you can acquire later on.</p>

<pre><code class="language-java">// Buffer.java

public final Buffer mark() {
    mark = position;
    return this;
}
</code></pre>

<p>See <code>markValue</code> for read and <code>reset</code> to resets this buffer&rsquo;s position to the previously-marked position.</p>

<pre><code class="language-java">// Buffer.java

final int markValue() { 
    return mark;
}

public final Buffer reset() {
    int m = mark;
    if (m &lt; 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
</code></pre>

<h1 id="equals-and-compareto"><code>equals()</code> and <code>compareTo()</code></h1>

<p>Another method in <code>Buffer</code> that must be refferd is <code>equals()</code>. It is more complicated comparing the equality of two Buffers.</p>

<pre><code class="language-java">// ByteBuffer.java
public boolean equals(Object ob) {
    if (this == ob)
        return true;
    if (!(ob instanceof ByteBuffer))
        return false;
    ByteBuffer that = (ByteBuffer)ob;
    if (this.remaining() != that.remaining())
        return false;
    int p = this.position();
    for (int i = this.limit() - 1, j = that.limit() - 1; i &gt;= p; i--, j--)
        if (!equals(this.get(i), that.get(j)))
            return false;
    return true;
}
</code></pre>

<p>Two buffers are equal if:</p>

<ol>
<li>They are of the same type (byte, char, int etc.)</li>
<li>They have the same amount of remaining bytes, chars etc. in the buffer.</li>
<li>All remaining bytes, chars etc. are equal.</li>
</ol>

<p>It&rsquo;s inevictable to involve <code>compareTo()</code> since <code>equals()</code> appears.</p>

<pre><code class="language-java">// ByteBuffer.java

public int compareTo(ByteBuffer that) {
    int n = this.position() + Math.min(this.remaining(), that.remaining());
    for (int i = this.position(), j = that.position(); i &lt; n; i++, j++) {
        int cmp = compare(this.get(i), that.get(j));
        if (cmp != 0)
            return cmp;
    }
    return this.remaining() - that.remaining();
}
</code></pre>

<p>A buffer is considered &ldquo;smaller&rdquo; than another buffer if:</p>

<ol>
<li>The first element which is equal to the corresponding element in the other buffer, is smaller than that in the other buffer.</li>
<li>All elements are equal, but the first buffer runs out of elements before the second buffer does (it has fewer elements).</li>
</ol>

<p><strong>Reference</strong></p>

<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li>
<li><a href="https://www.javacodegeeks.com/2018/07/java-nio-tutorial.html">Java NIO Tutorial</a></li>
<li><a href="https://juejin.im/post/5af942c6f265da0b7026050c">nio你了解多少？</a></li>
</ul>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/en/tags/java.nio/">java.nio</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/en/post/learn-consciously/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Learn Consciously</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/en/post/how-master-detect-death-of-regionserver/">
            <span class="next-text nav-default">How HMaster Detect Death of RegionServer</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
  <a href="https://hellokangning.github.io/en/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-105833321-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
