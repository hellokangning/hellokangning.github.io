<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Multiversion Concurrency Control in HBase - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="Multiversion Concurrency Control (MVCC for short) manages the read/write consistency. This provides an interface for readers to determine what entries to ignore, and a mechanism for writers to obtain new write numbers, then &amp;ldquo;commit&amp;rdquo; the new writes for readers to read (thus forming atomic transactions).
" />
<meta name="keywords" content="MVCC, HBase" />







<meta name="generator" content="Hugo 0.52" />


<link rel="canonical" href="https://hellokangning.github.io/en/post/multiversion-concurrency-control-in-hbase/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Multiversion Concurrency Control in HBase" />
<meta property="og:description" content="Multiversion Concurrency Control (MVCC for short) manages the read/write consistency. This provides an interface for readers to determine what entries to ignore, and a mechanism for writers to obtain new write numbers, then &ldquo;commit&rdquo; the new writes for readers to read (thus forming atomic transactions)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/en/post/multiversion-concurrency-control-in-hbase/" /><meta property="article:published_time" content="2017-12-27T16:19:17&#43;08:00"/>
<meta property="article:modified_time" content="2018-01-09T16:19:17&#43;08:00"/>

<meta itemprop="name" content="Multiversion Concurrency Control in HBase">
<meta itemprop="description" content="Multiversion Concurrency Control (MVCC for short) manages the read/write consistency. This provides an interface for readers to determine what entries to ignore, and a mechanism for writers to obtain new write numbers, then &ldquo;commit&rdquo; the new writes for readers to read (thus forming atomic transactions).">


<meta itemprop="datePublished" content="2017-12-27T16:19:17&#43;08:00" />
<meta itemprop="dateModified" content="2018-01-09T16:19:17&#43;08:00" />
<meta itemprop="wordCount" content="1481">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Multiversion Concurrency Control in HBase"/>
<meta name="twitter:description" content="Multiversion Concurrency Control (MVCC for short) manages the read/write consistency. This provides an interface for readers to determine what entries to ignore, and a mechanism for writers to obtain new write numbers, then &ldquo;commit&rdquo; the new writes for readers to read (thus forming atomic transactions)."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/en/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/en/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/en/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/en/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/en/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/zh/">
        <li class="mobile-menu-item">中文</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/en/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/en/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/zh/">中文</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Multiversion Concurrency Control in HBase</h1>

      <div class="post-meta">
        <span class="post-time"> Dec 27, 2017 </span>
        <div class="post-category">
            
              <a href="/en/categories/hbase/"> HBase </a>
            
          </div>
        <span class="more-meta"> 1481 words </span>
        <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#why-mvcc-is-needed">Why MVCC is needed</a>
<ul>
<li><a href="#write-write-synchronization">Write-Write Synchronization</a></li>
<li><a href="#read-write-synchronization">Read-Write Synchronization</a></li>
</ul></li>
<li><a href="#how-mvcc-works">How MVCC works</a></li>
<li><a href="#mvcc-in-source-code">MVCC in Source Code</a>
<ul>
<li><a href="#begin"><code>begin</code></a></li>
<li><a href="#completeandwait"><code>completeAndWait</code></a></li>
<li><a href="#advanceto"><code>advanceTo</code></a></li>
<li><a href="#complete"><code>complete</code></a></li>
</ul></li>
<li><a href="#where-mvcc-is-used">Where MVCC is used</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>Multiversion Concurrency Control (MVCC for short) manages the read/write consistency. This provides an interface for readers to determine what entries to ignore, and a mechanism for writers to obtain new write numbers, then &ldquo;commit&rdquo; the new writes for readers to read (thus forming atomic transactions).</p>

<h1 id="why-mvcc-is-needed">Why MVCC is needed</h1>

<p>Unlike traditional relational databases, HBase only provides ACID semantics on a per-row basis.</p>

<h2 id="write-write-synchronization">Write-Write Synchronization</h2>

<p>Consider two concurrent writes to same row that represent {company, role} combinations:</p>

<p><img src="/images/hbase-two-writes-to-same-row.png" alt="Two writes to the same row" /></p>

<p>We know that HBase will perform the following steps for each write:</p>

<ol>
<li>Write to Write-Ahead-Log (WAL)</li>
<li>Update MemStore: write each data cell [the (row, column) pair] to the memstore.</li>
</ol>

<p>Then, assume we have no concurrency control over the writes and consider the following order of events:</p>

<p><img src="/images/hbase-write-possible-order.png" alt="" /></p>

<p>At the end, we are left with the following state:</p>

<p><img src="/images/hbase-inconsistent-result.png" alt="" /></p>

<p>The simplest solution that comes to our mind is to provide exclusive locks per row in order to provide isolation for writes that update the same row.  So, our new list of steps for writes is as follows (new steps are in bold).</p>

<ol>
<li><strong>Obtain Row Lock</strong></li>
<li>Write to Write-Ahead-Log (WAL)</li>
<li>Update MemStore: write each cell to the memstore</li>
<li><strong>Release Row Lock</strong></li>
</ol>

<p>It works for write-write synchronization.</p>

<h2 id="read-write-synchronization">Read-Write Synchronization</h2>

<p>However, if it involves reads,</p>

<p><img src="/images/hbase-possible-order-with-locks.png" alt="" /></p>

<p>Therefore, we need some concurrency control to deal with read-write synchronization. The simplest solution would be to have the reads obtain and release the row locks in the same manner as the writes.  This would resolve the ACID violation, but the downside is that our reads and writes would both contend for the row locks, slowing each other down.</p>

<h1 id="how-mvcc-works">How MVCC works</h1>

<p>Instead, HBase uses a form of MVCC to avoid requiring the reads to obtain row locks. MVCC works in HBase as follows:</p>

<p>For writes:</p>

<ol>
<li>After acquiring the RowLock, each write operation is immediately assigned a write number.</li>
<li>Each data cell in the write stores its write number.</li>
<li>A write operation completes by declaring it is finished with the write number.</li>
</ol>

<p>For reads:</p>

<ol>
<li>Each read operation is first assigned a read timestamp, called a read point.</li>
<li>The read point is assigned to be the highest integer such that all writes with write number <code>&lt;= x</code> have been completed.</li>
<li>A read r for a certain (row, column) combination returns the data cell with the matching (row, column) whose write number is the largest value that is less than or equal to the read point of <code>r</code>.</li>
</ol>

<p>Let’s look at the operations using Multiversion Concurrency Control:</p>

<p><img src="/images/hbase-write-steps-with-mvcc.png" alt="" /></p>

<p>Now, let’s consider the read that begins after step <code>Restaurant [wn=2]</code> but before the step <code>Waiter [wn=2]</code>.  From rule 1 and 2, its read point will be assigned to 1.  From <code>r3</code>, it will read the values with write number of 1, leaving us with:</p>

<p><img src="/images/hbase-consistent-answer-with-mvcc.png" alt="" /></p>

<p>Let’s put this all together by listing the steps for a write with Multiversion Concurrency Control: (new steps required for read-write synchronization are in bold):</p>

<ol>
<li>Obtain Row Lock</li>
<li><strong>Acquire New Write Number</strong></li>
<li>Write to Write-Ahead-Log (WAL)</li>
<li>Update MemStore: write each cell to the memstore</li>
<li><strong>Finish Write Number</strong></li>
<li>Release Row Lock</li>
</ol>

<h1 id="mvcc-in-source-code">MVCC in Source Code</h1>

<p>The <code>MultiVersionConsistencyControl</code> class implements Multiversion Consistency Control in HBase.</p>

<p>A few member variables lists here:</p>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

public class MultiVersionConcurrencyControl {
  final AtomicLong readPoint = new AtomicLong(0);
  final AtomicLong writePoint = new AtomicLong(0);
  private final Object readWaiters = new Object();

  // This is the pending queue of writes.
  private final LinkedList&lt;WriteEntry&gt; writeQueue = new LinkedList&lt;&gt;();
}
</code></pre>

<p>From <code>doMiniBatchMutate</code> method in <a href="https://hellokangning.github.io/en/post/a-lifecycle-of-hbase-put-server-side/#dominibatchmutate">HRegion.java</a>, we can conclude the order of calling <code>MultiVersionConcurrencyControl</code>&rsquo;s member methods:</p>

<ol>
<li><code>begin</code></li>
<li><code>completeAndWait</code></li>
<li><code>advanceTo</code></li>
<li><code>complete</code></li>
</ol>

<p>Next, let&rsquo;s see what these methods do.</p>

<h2 id="begin"><code>begin</code></h2>

<p>For <code>begin</code>, it starts a write transaction by:</p>

<ol>
<li>Increment <code>writePoint</code>.</li>
<li>Create a new <code>WriteEntry</code> with a new write number.</li>
<li>Add new <code>WriteEntry</code> to our queue of ongoing writes.</li>
<li>call <code>Runnable</code>.</li>
<li>Return this <code>WriteEntry</code> instance.</li>
</ol>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

private final LinkedList&lt;WriteEntry&gt; writeQueue = new LinkedList&lt;&gt;();

public WriteEntry begin(Runnable action) {
  synchronized (writeQueue) {
    long nextWriteNumber = writePoint.incrementAndGet();
    WriteEntry e = new WriteEntry(nextWriteNumber);
    writeQueue.add(e);
    action.run();
    return e;
  }
}
</code></pre>

<h2 id="completeandwait"><code>completeAndWait</code></h2>

<p>To complete the write transaction and wait for it to be visible, call <code>completeAndWait(WriteEntry)</code>. It waits until the read point catches up to our write. At the end of this call, the global read point is at least as large as the write point of the passed in WriteEntry. Thus, the write is visible to MVCC readers.</p>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

public void completeAndWait(WriteEntry e) {
  if (!complete(e)) {
    waitForRead(e);
  }
}
</code></pre>

<p>Take <code>waitForRead(WriteEntry)</code> first if you don&rsquo;t mind, since <code>complete(WriteEntry)</code> will be penetrated later.</p>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

private final Object readWaiters = new Object();

// Wait for the global readPoint to advance up to the passed in write entry number.
void waitForRead(WriteEntry e) {
  boolean interrupted = false;
  int count = 0;
  synchronized (readWaiters) {
    while (readPoint.get() &lt; e.getWriteNumber()) {
      if (count % 100 == 0 &amp;&amp; count &gt; 0) {
        LOG.warn(&quot;STUCK: &quot; + this);
      }
      count++;
      try {
        readWaiters.wait(10);
      } catch (InterruptedException ie) {
        // We were interrupted... finish the loop -- i.e. cleanup --and then
        // on our way out, reset the interrupt flag.
        interrupted = true;
      }
    }
  }
  if (interrupted) {
    Thread.currentThread().interrupt();
  }
}
</code></pre>

<h2 id="advanceto"><code>advanceTo</code></h2>

<p><code>advanceTo</code> steps the MVCC forward on to a new read/write basis, which calls <code>tryAdvanceTo</code> in the loop until it succeeds.</p>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

public void advanceTo(long newStartPoint) {
  while (true) {
    long seqId = this.getWritePoint();
    if (seqId &gt;= newStartPoint) break;
    if (this.tryAdvanceTo(/* newSeqId = */ newStartPoint, /* expected = */ seqId)) break;
  }
}

/*
 + @param newStartPoint Point to move read and write points to.
 + @param expected If not -1 (#NONE)
 + @return Returns false if expected is not equal to the
 + current readPoint or if startPoint is less than current readPoint
*/
boolean tryAdvanceTo(long newStartPoint, long expected) {
  synchronized (writeQueue) {
    long currentRead = this.readPoint.get();
    long currentWrite = this.writePoint.get();
    if (currentRead != currentWrite) {
      throw new RuntimeException(&quot;Already used this mvcc; currentRead=&quot; + currentRead +
        &quot;, currentWrite=&quot; + currentWrite + &quot;; too late to tryAdvanceTo&quot;);
    }
    if (expected != NONE &amp;&amp; expected != currentRead) {
      return false;
    }

    if (newStartPoint &lt; currentRead) {
      return false;
    }

    readPoint.set(newStartPoint);
    writePoint.set(newStartPoint);
  }
  return true;
}
</code></pre>

<h2 id="complete"><code>complete</code></h2>

<p><code>complete</code> marks the <code>WriteEntry</code> as complete and advances the read point as much as possible.</p>

<p><code>complete</code> is called even if the write has FAILED (AFTER backing out the write transaction changes completely) so we can clean up the outstanding transaction.</p>

<pre><code class="language-java">// MultiVersionConcurrencyControl.java

private final LinkedList&lt;WriteEntry&gt; writeQueue = new LinkedList&lt;&gt;();

public boolean complete(WriteEntry writeEntry) {
  synchronized (writeQueue) {
    writeEntry.markCompleted();
    long nextReadValue = NONE;
    boolean ranOnce = false;
    while (!writeQueue.isEmpty()) {
      ranOnce = true;
      WriteEntry queueFirst = writeQueue.getFirst();

      if (nextReadValue &gt; 0) {
        if (nextReadValue + 1 != queueFirst.getWriteNumber()) {
          throw new RuntimeException(&quot;Invariant in complete violated, nextReadValue=&quot;
              + nextReadValue + &quot;, writeNumber=&quot; + queueFirst.getWriteNumber());
        }
      }

      if (queueFirst.isCompleted()) {
        nextReadValue = queueFirst.getWriteNumber();
        writeQueue.removeFirst();
      } else {
        break;
      }
    }

    if (!ranOnce) {
      throw new RuntimeException(&quot;There is no first!&quot;);
    }

    if (nextReadValue &gt; 0) {
      synchronized (readWaiters) {
        readPoint.set(nextReadValue);
        readWaiters.notifyAll();
      }
    }
    return readPoint.get() &gt;= writeEntry.getWriteNumber();
  }
}
</code></pre>

<h1 id="where-mvcc-is-used">Where MVCC is used</h1>

<p>For writes, many methods in <code>HRegion.java</code> depends on MVCC,</p>

<ol>
<li><code>put</code></li>
<li><code>checkAndPut</code></li>
<li><code>delete</code></li>
<li><code>checkAndDelete</code></li>
<li><code>internalFlushcache</code></li>
<li><code>mutateRow</code></li>
<li><code>mutateRowsWithLocks</code></li>
<li><code>batchMutate</code></li>
</ol>

<p>For reads, a member, <code>private final ConcurrentHashMap&lt;RegionScanner, Long&gt; scannerReadPoints</code> in <code>HRegion.java</code>, is responsible for recording each read point.</p>

<p>If you <code>get</code> or <code>scan</code> in HBase, a <code>RegionScannerImpl</code> will be created by calling <code>getScanner</code>.</p>

<pre><code class="language-java">// HRegion.java

public RegionScannerImpl getScanner(Scan scan, List&lt;KeyValueScanner&gt; additionalScanners)
    throws IOException {
  return getScanner(scan, additionalScanners, HConstants.NO_NONCE, HConstants.NO_NONCE);
}
</code></pre>

<p>Notice the input parameter <code>KeyValueScanner</code>. One of its child <code>StoreFileScanner</code>&rsquo;s <code>next</code> method is called to every time get a new cell.</p>

<pre><code class="language-java">// StoreFileScanner.java

public Cell next() throws IOException {
  Cell retKey = cur;

  try {
    // only seek if we aren't at the end. cur == null implies 'end'.
    if (cur != null) {
      hfs.next();
      setCurrentCell(hfs.getCell());
      if (hasMVCCInfo || this.reader.isBulkLoaded()) {
        skipKVsNewerThanReadpoint();
      }
    }
  } catch (FileNotFoundException e) {
    throw e;
  } catch(IOException e) {
    throw new IOException(&quot;Could not iterate &quot; + this, e);
  }
  return retKey;
}

protected boolean skipKVsNewerThanReadpoint() throws IOException {
  // We want to ignore all key-values that are newer than our current
  // readPoint
  Cell startKV = cur;
  while(enforceMVCC
      &amp;&amp; cur != null
      &amp;&amp; (cur.getSequenceId() &gt; readPt)) {
    boolean hasNext = hfs.next();
    setCurrentCell(hfs.getCell());
    if (hasNext &amp;&amp; this.stopSkippingKVsIfNextRow
        &amp;&amp; getComparator().compareRows(cur, startKV) &gt; 0) {
      return false;
    }
  }

  if (cur == null) {
    return false;
  }

  return true;
}
</code></pre>

<p><strong>Reference</strong></p>

<ol>
<li><a href="https://blogs.apache.org/hbase/entry/apache_hbase_internals_locking_and">Apache HBase Internals: Locking and Multiversion Concurrency Control</a></li>
<li><a href="https://draveness.me/database-concurrency-control">浅谈数据库并发控制 - 锁和 MVCC</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSPK3V_7.0.0/com.ibm.swg.im.soliddb.sql.doc/doc/pessimistic.vs.optimistic.concurrency.control.html">PESSIMISTIC vs. OPTIMISTIC concurrency control</a></li>
<li><a href="http://hbasefly.com/2017/07/26/transaction-2/">数据库事务系列－HBase行级事务模型</a></li>
<li><a href="http://www.codeceo.com/article/hbase-transaction.html">HBase 事务和并发控制机制原理</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion concurrency control</a></li>
<li><a href="http://www.thebigdata.cn/HBase/14910.html">HBase中MVCC的实现机制及应用情况</a></li>
<li><a href="http://hadoop-hbase.blogspot.hk/2012/11/hbase-mvcc-and-built-in-atomic.html">HBase MVCC and built-in Atomic Operations</a></li>
<li><a href="http://yui2010.github.io/blog/2.html">HBase MVCC</a></li>
</ol>
    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/en/post/2017-in-review-look-ahead/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">2017 in Review and Look Ahead</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/en/post/a-lifecycle-of-hbase-put-server-side/">
            <span class="next-text nav-default">A Lifecycle of HBase&#39;s Put: Server-side</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
      <a href="https://www.douban.com/people/hellokangning/" class="iconfont icon-douban" title="douban"></a>
      <a href="https://www.instagram.com/hellokangning/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="https://hellokangning.github.io/en/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-105833321-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
