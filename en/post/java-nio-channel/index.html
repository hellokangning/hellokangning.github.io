<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java NIO: Channel - Qing&#39;s Landing</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" /><meta name="description" content="Channels are similar to streams available for blocking IO with a few differences:
 You can both read and write to Channels. Streams are typically one-way (read or write). Channels can be read and written asynchronously. Channels always read to, or write from, a Buffer.  The Channels have multiple implementations depending on the data to be read or written:
 FileChannel: Used to read and write data from and to the files DatagramChannel: Used for data exchange over network using UDP packets SocketChannel: TCP channel to exchange data over TCP sockets ServerSocketChannel: An implementation similar to a web server listening to requests over a specific TCP port. It creates a new SocketChannel instance for every new connection  This post will take FileChannel for further exploration, from example to implementation.
" /><meta name="keywords" content="Java, NIO, Channel" />






<meta name="generator" content="Hugo 0.52 with even 4.0.0" />


<link rel="canonical" href="https://hellokangning.github.io/en/post/java-nio-channel/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.93844dae.min.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Java NIO: Channel" />
<meta property="og:description" content="Channels are similar to streams available for blocking IO with a few differences:


You can both read and write to Channels. Streams are typically one-way (read or write).
Channels can be read and written asynchronously.
Channels always read to, or write from, a Buffer.


The Channels have multiple implementations depending on the data to be read or written:


FileChannel: Used to read and write data from and to the files
DatagramChannel: Used for data exchange over network using UDP packets
SocketChannel: TCP channel to exchange data over TCP sockets
ServerSocketChannel: An implementation similar to a web server listening to requests over a specific TCP port. It creates a new SocketChannel instance for every new connection


This post will take FileChannel for further exploration, from example to implementation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/en/post/java-nio-channel/" /><meta property="article:published_time" content="2018-07-19T11:00:38&#43;08:00"/>
<meta property="article:modified_time" content="2018-07-19T11:00:38&#43;08:00"/>

<meta itemprop="name" content="Java NIO: Channel">
<meta itemprop="description" content="Channels are similar to streams available for blocking IO with a few differences:


You can both read and write to Channels. Streams are typically one-way (read or write).
Channels can be read and written asynchronously.
Channels always read to, or write from, a Buffer.


The Channels have multiple implementations depending on the data to be read or written:


FileChannel: Used to read and write data from and to the files
DatagramChannel: Used for data exchange over network using UDP packets
SocketChannel: TCP channel to exchange data over TCP sockets
ServerSocketChannel: An implementation similar to a web server listening to requests over a specific TCP port. It creates a new SocketChannel instance for every new connection


This post will take FileChannel for further exploration, from example to implementation.">


<meta itemprop="datePublished" content="2018-07-19T11:00:38&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-19T11:00:38&#43;08:00" />
<meta itemprop="wordCount" content="1426">



<meta itemprop="keywords" content="java.nio," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java NIO: Channel"/>
<meta name="twitter:description" content="Channels are similar to streams available for blocking IO with a few differences:


You can both read and write to Channels. Streams are typically one-way (read or write).
Channels can be read and written asynchronously.
Channels always read to, or write from, a Buffer.


The Channels have multiple implementations depending on the data to be read or written:


FileChannel: Used to read and write data from and to the files
DatagramChannel: Used for data exchange over network using UDP packets
SocketChannel: TCP channel to exchange data over TCP sockets
ServerSocketChannel: An implementation similar to a web server listening to requests over a specific TCP port. It creates a new SocketChannel instance for every new connection


This post will take FileChannel for further exploration, from example to implementation."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/en/" class="logo">Qing&#39;s Landing</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/en/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/en/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/en/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/en/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/zh/">
        <li class="mobile-menu-item">中文</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/en/" class="logo">Qing&#39;s Landing</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/en/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/zh/">中文</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java NIO: Channel</h1>

      <div class="post-meta">
        <span class="post-time"> Jul 19, 2018 </span>
        <div class="post-category">
            <a href="/en/categories/java/"> Java </a>
            </div>
          <span class="more-meta"> 1426 words </span>
          <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#basic-channel-example">Basic Channel Example</a></li>
<li><a href="#opening-a-filechannel">Opening a FileChannel</a></li>
<li><a href="#reading-data-from-a-filechannel">Reading Data from a FileChannel</a></li>
<li><a href="#writing-data-to-a-filechannel">Writing Data to a FileChannel</a></li>
<li><a href="#closing-a-filechannel">Closing a FileChannel</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Channels are similar to streams available for blocking IO with a few differences:</p>

<ul>
<li>You can both read and write to Channels. Streams are typically one-way (read or write).</li>
<li>Channels can be read and written asynchronously.</li>
<li>Channels always read to, or write from, a Buffer.</li>
</ul>

<p>The Channels have multiple implementations depending on the data to be read or written:</p>

<ul>
<li>FileChannel: Used to read and write data from and to the files</li>
<li>DatagramChannel: Used for data exchange over network using UDP packets</li>
<li>SocketChannel: TCP channel to exchange data over TCP sockets</li>
<li>ServerSocketChannel: An implementation similar to a web server listening to requests over a specific TCP port. It creates a new SocketChannel instance for every new connection</li>
</ul>

<p>This post will take FileChannel for further exploration, from example to implementation.</p>

<h1 id="basic-channel-example">Basic Channel Example</h1>

<p>Here is a basic example that uses a FileChannel to read some data into a Buffer:</p>

<pre><code class="language-java">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

  System.out.println(&quot;Read &quot; + bytesRead);
  buf.flip();

  while(buf.hasRemaining()){
      System.out.print((char) 
      buf.get());
  }

  buf.clear();
  bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<p>Java NIO supports built-in scatter and gather.</p>

<ul>
<li>A &ldquo;scattering read&rdquo; reads data channel into more than one buffer. Here is a code example and an illustration.</li>
<li>A &ldquo;gathering write&rdquo; writes data from more than one buffer into a single channel.</li>
</ul>

<p>For more explanation about scatter and gather, see <a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html">Java NIO Scatter / Gather
</a>. In this post, I consider the interaction between one channel and one buffer only for briefness.</p>

<p><img src="/images/java-nio-channel-class.png" alt="" /></p>

<h1 id="opening-a-filechannel">Opening a FileChannel</h1>

<p>FileChannel allows you read from or write to a file. A FileChannel cannot be non-blocking which upsets you.</p>

<p>You cannot open FileChannel directly, but can obtain a FileChannel via a RandomAccessFile, InputStream or OutputStream. From the above basic example, we can see how RandomAccessFile open a FileChannel.</p>

<pre><code class="language-java">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();
</code></pre>

<p>What actually RandomAccessFile does lists as follows,</p>

<pre><code class="language-java">// RandomAccessFile.java

public final FileChannel getChannel() {
    synchronized (this) {
        if (channel == null) {
            channel = FileChannelImpl.open(fd, path, true, rw, this);
        }
        return channel;
    }
}
</code></pre>

<p>After jumping to FileChannelImpl, <code>open()</code> method justs construct an instance of FileChannelImpl.</p>

<pre><code class="language-java">public static FileChannel open(FileDescriptor fd, String path,
                               boolean readable, boolean writable,
                               Object parent)
{
    return new FileChannelImpl(fd, path, readable, writable, false, parent);
}

private FileChannelImpl(FileDescriptor fd, String path, boolean readable,
                        boolean writable, boolean direct, Object parent)
{
    this.fd = fd;
    this.readable = readable;
    this.writable = writable;
    this.parent = parent;
    this.path = path;
    this.direct = direct;
    this.nd = new FileDispatcherImpl();
    if (direct) {
        assert path != null;
        this.alignment = nd.setDirectIO(fd, path);
    } else {
        this.alignment = -1;
    }

    // Register a cleaning action if and only if there is no parent
    // as the parent will take care of closing the file descriptor.
    // FileChannel is used by the LambdaMetaFactory so a lambda cannot
    // be used here hence we use a nested class instead.
    this.closer = parent != null ? null :
        CleanerFactory.cleaner().register(this, new Closer(fd));
}
</code></pre>

<p>As to Constructor, let&rsquo;s the fields involved in FileChannelImpl.</p>

<pre><code class="language-java">// FileChannelImpl.java

public class FileChannelImpl
    extends FileChannel
{
    // Memory allocation size for mapping buffers
    private static final long allocationGranularity;

    // Access to FileDescriptor internals
    private static final JavaIOFileDescriptorAccess fdAccess =
        SharedSecrets.getJavaIOFileDescriptorAccess();

    // Used to make native read and write calls
    private final FileDispatcher nd;

    // File descriptor
    private final FileDescriptor fd;

    // File access mode (immutable)
    private final boolean writable;
    private final boolean readable;

    // Required to prevent finalization of creating stream (immutable)
    private final Object parent;

    // The path of the referenced file
    // (null if the parent stream is created with a file descriptor)
    private final String path;

    // Thread-safe set of IDs of native threads, for signalling
    private final NativeThreadSet threads = new NativeThreadSet(2);

    // Lock for operations involving position and size
    private final Object positionLock = new Object();

    // Positional-read is not interruptible
    private volatile boolean uninterruptible;

    // DirectIO flag
    private final boolean direct;

    // IO alignment value for DirectIO
    private final int alignment;

    // Cleanable with an action which closes this channel's file descriptor
    private final Cleanable closer;
}
</code></pre>

<h1 id="reading-data-from-a-filechannel">Reading Data from a FileChannel</h1>

<p>It&rsquo;s easy to read data from a FileChannel to a allocated Buffer by calling <code>read()</code> method like this,</p>

<pre><code class="language-java">ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);
</code></pre>

<p>The <code>read()</code> underneath tackles read operation with the following steps:</p>

<ul>
<li>ensure this channel is open</li>
<li>make certain the file access mode is readable</li>
<li>check whether or not the position of channel is aligned</li>
<li>marks the beginning of the I/O operation that might block indefinitely.</li>
<li>check the buffer is readable</li>
<li>allocate a temporary buffer and write data into it</li>
<li>assign newborn buffer to destination buffer</li>
<li>normalize the status of this I/O operation</li>
</ul>

<pre><code class="language-java">// FileChannelImpl.java
public int read(ByteBuffer dst) throws IOException {
    ensureOpen();
    if (!readable)
        throw new NonReadableChannelException();
    synchronized (positionLock) {
        if (direct)
            Util.checkChannelPositionAligned(position(), alignment);
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            do {
                n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
            } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n &gt; 0);
            assert IOStatus.check(n);
        }
    }
}

// IOUtil.java
static int read(FileDescriptor fd, ByteBuffer dst, long position,
                boolean directIO, int alignment, NativeDispatcher nd)
    throws IOException
{
    if (dst.isReadOnly())
        throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
    if (dst instanceof DirectBuffer)
        return readIntoNativeBuffer(fd, dst, position,
                directIO, alignment, nd);

    // Substitute a native buffer
    ByteBuffer bb;
    int rem = dst.remaining();
    if (directIO) {
        Util.checkRemainingBufferSizeAligned(rem, alignment);
        bb = Util.getTemporaryAlignedDirectBuffer(rem,
                                                  alignment);
    } else {
        bb = Util.getTemporaryDirectBuffer(rem);
    }
    try {
        int n = readIntoNativeBuffer(fd, bb, position,
                directIO, alignment,nd);
        bb.flip();
        if (n &gt; 0)
            dst.put(bb);
        return n;
    } finally {
        Util.offerFirstTemporaryDirectBuffer(bb);
    }
}
</code></pre>

<p>Eventually, the <code>read</code> operation is achieved by <code>readIntoNativeBuffer</code> with the help of NativeDispatcher, which, as its name implies, will call native method of <code>read0</code> and <code>write0</code>.</p>

<pre><code class="language-java">// IOUtil.java

private static int readIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,
                                        long position, boolean directIO,
                                        int alignment, NativeDispatcher nd)
    throws IOException
{
    int pos = bb.position();
    int lim = bb.limit();
    assert (pos &lt;= lim);
    int rem = (pos &lt;= lim ? lim - pos : 0);

    if (directIO) {
        Util.checkBufferPositionAligned(bb, pos, alignment);
        Util.checkRemainingBufferSizeAligned(rem, alignment);
    }

    if (rem == 0)
        return 0;
    int n = 0;
    if (position != -1) {
        n = nd.pread(fd, ((DirectBuffer)bb).address() + pos,
                     rem, position);
    } else {
        n = nd.read(fd, ((DirectBuffer)bb).address() + pos, rem);
    }
    if (n &gt; 0)
        bb.position(pos + n);
    return n;
}
</code></pre>

<h1 id="writing-data-to-a-filechannel">Writing Data to a FileChannel</h1>

<p>Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter. Here is an example.</p>

<pre><code class="language-java">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
    channel.write(buf);
}
</code></pre>

<p>Because of no guarantee of how many bytes the <code>write()</code> method writes to the FileChannel, <code>write()</code> is called repeatedly until the buffer has no further bytes to write.</p>

<p>The steps of <code>write()</code> of FileChannel is similar with <code>read()</code> concerning position check and native operation.</p>

<pre><code class="language-java">// FileChannelImpl.java

public int write(ByteBuffer src) throws IOException {
    ensureOpen();
    if (!writable)
        throw new NonWritableChannelException();
    synchronized (positionLock) {
        if (direct)
            Util.checkChannelPositionAligned(position(), alignment);
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            do {
                n = IOUtil.write(fd, src, -1, direct, alignment, nd);
            } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n &gt; 0);
            assert IOStatus.check(n);
        }
    }
}
</code></pre>

<h1 id="closing-a-filechannel">Closing a FileChannel</h1>

<p>When you are done using a FileChannel you must close it by <code>channel.close();</code>.<br />
What <code>implCloseChannel</code> does includes:</p>

<ul>
<li>check whether the FileDescriptor is valid</li>
<li>release and invalidate any locks that we still hold</li>
<li>signal any threads blocked on this channel</li>
<li>close FileDescriptor</li>
<li>perform the cleaning action</li>
</ul>

<pre><code class="language-java">// FileChannelImpl.java

protected void implCloseChannel() throws IOException {
    if (!fd.valid())
        return; // nothing to do

    if (fileLockTable != null) {
        for (FileLock fl: fileLockTable.removeAll()) {
            synchronized (fl) {
                if (fl.isValid()) {
                    nd.release(fd, fl.position(), fl.size());
                    ((FileLockImpl)fl).invalidate();
                }
            }
        }
    }

    threads.signalAndWait();

    if (parent != null) {

        // Close the fd via the parent stream's close method.  The parent
        // will reinvoke our close method, which is defined in the
        // superclass AbstractInterruptibleChannel, but the isOpen logic in
        // that method will prevent this method from being reinvoked.
        //
        ((java.io.Closeable)parent).close();
    } else if (closer != null) {
        // Perform the cleaning action so it is not redone when
        // this channel becomes phantom reachable.
        closer.clean();
    } else {
        fdAccess.close(fd);
    }
}
</code></pre>

<p><code>position()</code> and <code>truncate()</code> are skipped in this post, because they share analogous steps with <code>read()</code> and <code>write()</code>.</p>

<p><strong>Reference</strong></p>

<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li>
<li><a href="https://www.javacodegeeks.com/2018/07/java-nio-tutorial.html">Java NIO Tutorial</a></li>
<li><a href="https://juejin.im/post/5af942c6f265da0b7026050c">nio你了解多少？</a></li>
</ul>
    </div>

    <footer class="post-footer">
      <div class="post-tags">
          <a href="/en/tags/java.nio/">java.nio</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/en/post/java-nio-selector/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java NIO: Selector</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/en/post/learn-consciously/">
            <span class="next-text nav-default">Learn Consciously</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
      <a href="https://www.douban.com/people/hellokangning/" class="iconfont icon-douban" title="douban"></a>
      <a href="https://www.instagram.com/hellokangning/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="https://hellokangning.github.io/en/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.ece58db6.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-105833321-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
