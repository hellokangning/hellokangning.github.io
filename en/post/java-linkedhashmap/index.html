<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java LinkedHashMap - Guoqing Geng</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Guoqing Geng" />
  <meta name="description" content="As its name implies, LinkedHashMap is a hash table and linked list implementation of the Map interface, with predictable iteration order. Different with HashMap, it maintains a doubly-linked list runing through all of its entries, which also defines the iteration ordering, same as the order in which keys were inserted into the map. This order remains if a key is re-inserted into the map.
Like HashMap, LinkedHashMap provides constant-time performance for the basic operations add, contains and remove, assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list,
Thanks to the linked list, this kind of map is well-suited to building LRU caches. So my questions is how LinkedHashMap preserves the linked list when key changes.

" />
<meta name="keywords" content="Java, HashMap, LinkedHashMap" />







<meta name="generator" content="Hugo 0.40.1" />


<link rel="canonical" href="https://hellokangning.github.io/en/post/java-linkedhashmap/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Java LinkedHashMap" />
<meta property="og:description" content="As its name implies, LinkedHashMap is a hash table and linked list implementation of the Map interface, with predictable iteration order. Different with HashMap, it maintains a doubly-linked list runing through all of its entries, which also defines the iteration ordering, same as the order in which keys were inserted into the map. This order remains if a key is re-inserted into the map.

Like HashMap, LinkedHashMap provides constant-time performance for the basic operations add, contains and remove, assuming the hash function disperses elements properly among the buckets.  Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list,

Thanks to the linked list, this kind of map is well-suited to building LRU caches. So my questions is how LinkedHashMap preserves the linked list when key changes.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hellokangning.github.io/en/post/java-linkedhashmap/" />



<meta property="article:published_time" content="2016-06-10T20:01:59&#43;08:00"/>

<meta property="article:modified_time" content="2018-06-09T10:20:03&#43;08:00"/>











<meta itemprop="name" content="Java LinkedHashMap">
<meta itemprop="description" content="As its name implies, LinkedHashMap is a hash table and linked list implementation of the Map interface, with predictable iteration order. Different with HashMap, it maintains a doubly-linked list runing through all of its entries, which also defines the iteration ordering, same as the order in which keys were inserted into the map. This order remains if a key is re-inserted into the map.

Like HashMap, LinkedHashMap provides constant-time performance for the basic operations add, contains and remove, assuming the hash function disperses elements properly among the buckets.  Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list,

Thanks to the linked list, this kind of map is well-suited to building LRU caches. So my questions is how LinkedHashMap preserves the linked list when key changes.

">


<meta itemprop="datePublished" content="2016-06-10T20:01:59&#43;08:00" />
<meta itemprop="dateModified" content="2016-06-10T20:01:59&#43;08:00" />
<meta itemprop="wordCount" content="0">



<meta itemprop="keywords" content="java.util,Data Structure," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java LinkedHashMap"/>
<meta name="twitter:description" content="As its name implies, LinkedHashMap is a hash table and linked list implementation of the Map interface, with predictable iteration order. Different with HashMap, it maintains a doubly-linked list runing through all of its entries, which also defines the iteration ordering, same as the order in which keys were inserted into the map. This order remains if a key is re-inserted into the map.

Like HashMap, LinkedHashMap provides constant-time performance for the basic operations add, contains and remove, assuming the hash function disperses elements properly among the buckets.  Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list,

Thanks to the linked list, this kind of map is well-suited to building LRU caches. So my questions is how LinkedHashMap preserves the linked list when key changes.

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/en/" class="logo">Guoqing Geng</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/en/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/en/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/en/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/en/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/zh/">
        <li class="mobile-menu-item">中文</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/en/" class="logo">Guoqing Geng</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/en/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/en/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/zh/">中文</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java LinkedHashMap</h1>

      <div class="post-meta">
        <span class="post-time"> Jun 10, 2016 </span>
        <div class="post-category">
            
              <a href="/en/categories/java/"> Java </a>
            
          </div>
        <span class="more-meta"> 0 words </span>
        <span class="more-meta"> 0 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#data-structure">Data Structure</a></li>
<li><a href="#get"><code>get</code></a></li>
<li><a href="#put"><code>put</code></a>
<ul>
<li><a href="#newnode"><code>newNode</code></a></li>
<li><a href="#afternodeinsertion"><code>afterNodeInsertion</code></a></li>
</ul></li>
<li><a href="#remove"><code>remove</code></a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>As its name implies, <code>LinkedHashMap</code> is a hash table and linked list implementation of the <code>Map</code> interface, with predictable iteration order. Different with <code>HashMap</code>, it maintains a doubly-linked list runing through all of its entries, which also defines the iteration ordering, same as the order in which keys were inserted into the map. This order remains if a key is re-inserted into the map.</p>

<p>Like <code>HashMap</code>, <code>LinkedHashMap</code> provides constant-time performance for the basic operations <code>add</code>, <code>contains</code> and <code>remove</code>, assuming the hash function disperses elements properly among the buckets.  Performance is likely to be just slightly below that of <code>HashMap</code>, due to the added expense of maintaining the linked list,</p>

<p>Thanks to the linked list, this kind of map is well-suited to building LRU caches. So my questions is how <code>LinkedHashMap</code> preserves the linked list when key changes.</p>

<p></p>

<p><img src="/images/java-hashmap-class.png" alt="" /></p>

<p>First of all we must get through the data structure.</p>

<h1 id="data-structure">Data Structure</h1>

<p>Three variables in <code>LinkedHashMap</code> includes,</p>

<ul>
<li><code>head</code>: the head (eldest) of the doubly linked list</li>
<li><code>tail</code>: the tail (youngest) of the doubly linked list.</li>
<li><code>accessOrder</code>: the iteration ordering method for this linked hash map</li>
</ul>

<pre><code class="language-java">// LinkedHashMap.java

public class LinkedHashMap&lt;K,V&gt;
    extends HashMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;
{
    transient LinkedHashMap.Entry&lt;K,V&gt; head;
    transient LinkedHashMap.Entry&lt;K,V&gt; tail;
    final boolean accessOrder;
}
</code></pre>

<p>As to <code>LinkedHashMap.Entry&lt;K,V&gt;</code>, a nested class in <code>LinkedHashMap</code>, we can see,</p>

<pre><code class="language-java">// LinkedHashMap.java

static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>

<h1 id="get"><code>get</code></h1>

<p>As the subclass of <code>HashMap</code>, <code>LinkedHashMap</code> get value from the <code>table</code> of base class.</p>

<pre><code class="language-java">// LinkedHashMap.java

public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
</code></pre>

<p>It is advisable to keep this array for fast read, after which <code>afterNodeAccess</code> is called to update the linked list, moving the node just accessed to last of the list. You can see the details from comments in the code.</p>

<pre><code class="language-java">// LinkedHashMap.java

void afterNodeAccess(Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;

        // if p is the old head
        if (b == null)
            head = a; // update head
        else
            b.after = a; // kick p out

        // if p is not the tail    
        if (a != null)
            a.before = b; // kick p out
        else
            last = b; // make b the tail

        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>

<h1 id="put"><code>put</code></h1>

<p>There is no <code>put</code> method in <code>LinkedHashMap</code> which means the one from base class is not overwritten. But it overwrite the <code>newNode</code> called from <code>put</code>.</p>

<h2 id="newnode"><code>newNode</code></h2>

<pre><code class="language-java">// LinkedHashMap.java

Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
</code></pre>

<p>It&rsquo;s reasonable to infer <code>newNode</code> do some maintain work with the help of <code>linkNodeLast</code>.</p>

<pre><code class="language-java">// LinkedHashMap.java

private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    tail = p;

    // empty list
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}
</code></pre>

<p>Since the code is so succinct that we can discover it link the new node at the end of list.</p>

<h2 id="afternodeinsertion"><code>afterNodeInsertion</code></h2>

<p>Another method called from <code>put</code> and overwritten by <code>LinkedHashMap</code> is <code>afterNodeInsertion</code>.</p>

<pre><code class="language-java">// LinkedHashMap.java

void afterNodeInsertion(boolean evict) {
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>

<p><code>afterNodeInsertion</code> possibly removes eldest node from the list. Since <code>removeEldestEntry</code> always return <code>false</code>, so <code>afterNodeInsertion</code> does not modify the map in any way. <code>removeNode</code> is also in <code>HashMap</code> and keep intact, which will be discussed in the next section.</p>

<h1 id="remove"><code>remove</code></h1>

<p>Being left out by <a href="https://hellokangning.github.io/en/post/java-hashmap/">last post</a>, <code>remove</code> removes the mapping for the specified key from this map if present.</p>

<pre><code class="language-java">// HashMap.java

public V remove(Object key) {
    Node&lt;K,V&gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>

<p>Despite the nested if-else, <code>removeNode</code> does the following steps:</p>

<ul>
<li>locate the key to be deleted</li>
<li>update <code>table</code> and link key&rsquo;s previous node and next node</li>
<li>do some other work with <code>afterNodeRemoval</code></li>
</ul>

<p>For <code>afterNodeRemoval</code>, it unlink the node from linked list.</p>

<pre><code class="language-java">// LinkedHashMap.java

void afterNodeRemoval(Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    // isolate the node    
    p.before = p.after = null;

    // if it is head
    if (b == null)
        head = a;
    else
        b.after = a;

    // if it is tail    
    if (a == null)
        tail = b;
    else
        a.before = b;
}
</code></pre>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/en/tags/java.util/">java.util</a>
          
          <a href="/en/tags/data-structure/">Data Structure</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/en/post/java-treemap/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java TreeMap</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/en/post/java-hashmap/">
            <span class="next-text nav-default">Java HashMap</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'guoqing';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hellokangning@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.linkedin.com/in/guoqing-geng-9032b820/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hellokangning" class="iconfont icon-github" title="github"></a>
      <a href="https://www.douban.com/people/hellokangning/" class="iconfont icon-douban" title="douban"></a>
      <a href="https://www.instagram.com/hellokangning/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="https://hellokangning.github.io/en/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Guoqing Geng</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-105833321-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>







</body>
</html>
